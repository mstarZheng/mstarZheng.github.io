<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基本排序算法--JavaScript篇</title>
      <link href="/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-JavaScript%E7%AF%87/"/>
      <url>/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-JavaScript%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h4 id="1、插入排序"><a href="#1、插入排序" class="headerlink" title="1、插入排序"></a>1、插入排序</h4><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ckrdsciag30l70emk0v.gif" alt="插入排序"></p><ul><li>算法描述： <ol><li>从第一个元素开始，该元素可以认为已经被排序 </li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描 </li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置 </li><li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置 </li><li>将新元素插入到该位置后 </li><li>重复步骤 2~5</li></ol></li></ul><p>现有一组数组 arr = [5, 6, 3, 1, 8, 7, 2, 4]</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token number">6</span> <span class="token number">3</span> <span class="token number">1</span> <span class="token number">8</span> <span class="token number">7</span> <span class="token number">2</span> <span class="token number">4</span>  <span class="token comment" spellcheck="true">//第一个元素被认为已经被排序</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>  <span class="token number">3</span> <span class="token number">1</span> <span class="token number">8</span> <span class="token number">7</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token comment" spellcheck="true">//6与5比较，放在5的右边</span><span class="token punctuation">[</span><span class="token number">3</span>，<span class="token number">5</span>，<span class="token number">6</span><span class="token punctuation">]</span>  <span class="token number">1</span> <span class="token number">8</span> <span class="token number">7</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token comment" spellcheck="true">//3与6和5比较，都小，则放入数组头部</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>   <span class="token number">8</span> <span class="token number">7</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token comment" spellcheck="true">//1与3,5,6比较，则放入头部</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span>，<span class="token number">5</span>，<span class="token number">6</span>，<span class="token number">8</span><span class="token punctuation">]</span>   <span class="token number">7</span> <span class="token number">2</span> <span class="token number">4</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span>，<span class="token number">5</span>，<span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span>，<span class="token number">8</span><span class="token punctuation">]</span>  <span class="token number">2</span> <span class="token number">4</span><span class="token punctuation">[</span><span class="token number">1</span>，<span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span>，<span class="token number">5</span>，<span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span>，<span class="token number">8</span><span class="token punctuation">]</span> <span class="token number">4</span><span class="token punctuation">[</span><span class="token number">1</span>，<span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span>，<span class="token number">4</span>，<span class="token number">5</span>，<span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span>，<span class="token number">8</span><span class="token punctuation">]</span> </code></pre><ul><li><p>编程思路：</p><p>双层循环，外循环控制未排序的元素，内循环控制已排序的元素，将未排序元素设为标杆，与已排序的元素进行比较，小于则交换位置，大于则位置不动。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">insertSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> tmp<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        tmp  <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">></span>tmp<span class="token punctuation">)</span><span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>tmp<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">}</span></code></pre><p>时间复杂度O(n^2)、</p></li></ul><h4 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h4><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ckrs6axkg30in0g07e0.gif" alt="选择排序"></p><ul><li><p>算法描述：</p><p>直接从待排序数组中选择一个最小（或最大）数字，放入新数组中。</p></li></ul><pre class=" language-javascript"><code class="language-javascript">    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">3</span>  <span class="token number">8</span> <span class="token number">7</span> <span class="token number">2</span> <span class="token number">4</span>     <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">3</span>  <span class="token number">8</span> <span class="token number">7</span>  <span class="token number">4</span>     <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token number">5</span> <span class="token number">6</span>  <span class="token number">8</span> <span class="token number">7</span> <span class="token number">2</span> <span class="token number">4</span>     <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">8</span> <span class="token number">7</span>    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token number">6</span>  <span class="token number">8</span> <span class="token number">7</span>     <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token number">8</span> <span class="token number">7</span>      <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token number">8</span>      <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span> </code></pre><ul><li><p>编程思路：</p><p>先假设第一个元素为最小的，然后通过循环找出最小元素，然后同第一个元素交换，接着假设第二个元素，重复上述操作即可。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">selectSort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> length <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">,</span>      i<span class="token punctuation">,</span>      j<span class="token punctuation">,</span>      minIndex<span class="token punctuation">,</span>      minValue<span class="token punctuation">,</span>      temp<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>    minValue <span class="token operator">=</span> array<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//通过循环选出最小的</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> minValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>        minValue <span class="token operator">=</span> array<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 交换位置</span>    temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> minValue<span class="token punctuation">;</span>    array<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> array<span class="token punctuation">}</span></code></pre><p>时间复杂度O(n^2)</p></li></ul><h4 id="3、归并排序"><a href="#3、归并排序" class="headerlink" title="3、归并排序"></a>3、归并排序</h4><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cks25w67g30gc0dfaj5.gif" alt="归并排序"></p><ul><li><p>算法描述： </p><ol><li>把 n 个记录看成 n 个长度为 l 的有序子表 </li><li>进行两两归并使记录关键字有序，得到 n/2 个长度为 2 的有序子表 </li><li>重复第 2 步直到所有记录归并成一个长度为 n 的有序表为止。</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token number">5</span> <span class="token number">6</span> <span class="token number">3</span> <span class="token number">1</span> <span class="token number">8</span> <span class="token number">7</span> <span class="token number">2</span> <span class="token number">4</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token number">8</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span></code></pre></li><li><p>编程思路：将数组一直等分，然后合并</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">merge</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> right<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>      tmp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>      tmp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> tmp<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span>     <span class="token keyword">return</span> a<span class="token punctuation">;</span>  <span class="token keyword">var</span> mid <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">,</span> left <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> mid<span class="token punctuation">)</span>    <span class="token punctuation">,</span> right <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">mergeSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>时间复杂度O(nlogn)</p></li></ul><h4 id="4、快速排序"><a href="#4、快速排序" class="headerlink" title="4、快速排序"></a>4、快速排序</h4><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cksccgvog30il0cxq8w.gif" alt="快速排序"></p><ul><li><p>算法描述：</p><p>在数据集之中，选择一个元素作为”基准”（pivot）。<br>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为分区 (partition)操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。<br>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token number">5</span> <span class="token number">6</span> <span class="token number">3</span> <span class="token number">1</span> <span class="token number">8</span> <span class="token number">7</span> <span class="token number">2</span> <span class="token number">4</span>pivot<span class="token operator">|</span><span class="token number">5</span> <span class="token number">6</span> <span class="token number">3</span> <span class="token number">1</span> <span class="token number">9</span> <span class="token number">7</span> <span class="token number">2</span> <span class="token number">4</span><span class="token operator">|</span>storeIndex<span class="token number">5</span> <span class="token number">6</span> <span class="token number">3</span> <span class="token number">1</span> <span class="token number">9</span> <span class="token number">7</span> <span class="token number">2</span> <span class="token number">4</span><span class="token comment" spellcheck="true">//将5同6比较，大于则不更换</span><span class="token operator">|</span>storeIndex<span class="token number">3</span> <span class="token number">6</span> <span class="token number">5</span> <span class="token number">1</span> <span class="token number">9</span> <span class="token number">7</span> <span class="token number">2</span> <span class="token number">4</span><span class="token comment" spellcheck="true">//将5同3比较，小于则更换</span>  <span class="token operator">|</span>  storeIndex<span class="token number">3</span> <span class="token number">6</span> <span class="token number">1</span> <span class="token number">5</span> <span class="token number">9</span> <span class="token number">7</span> <span class="token number">2</span> <span class="token number">4</span><span class="token comment" spellcheck="true">//将5同1比较，小于则不更换</span>    <span class="token operator">|</span>   storeIndex<span class="token operator">...</span><span class="token number">3</span> <span class="token number">6</span> <span class="token number">1</span> <span class="token number">4</span> <span class="token number">9</span> <span class="token number">7</span> <span class="token number">2</span> <span class="token number">5</span><span class="token comment" spellcheck="true">//将5同4比较，小于则更换</span>      <span class="token operator">|</span>      storeIndex<span class="token number">3</span> <span class="token number">6</span> <span class="token number">1</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">7</span> <span class="token number">2</span> <span class="token number">9</span><span class="token comment" spellcheck="true">//将标准元素放到正确位置</span>      <span class="token operator">|</span>storeIndex pivot</code></pre><p>上述讲解了分区的过程，然后就是对每个子区进行同样做法</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token keyword">var</span> partitionIndex<span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> tmp<span class="token operator">=</span>arr<span class="token punctuation">[</span>partitionIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> left<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> right<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>tmp<span class="token punctuation">)</span><span class="token punctuation">{</span>            left<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            right<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token function">quickSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre></li></ul><p>上述版本会造成<strong>堆栈</strong>溢出，所以建议使用下面版本</p><p>原地分区版：主要区别在于先进行分区处理，将数组分为左小右大</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>right<span class="token punctuation">,</span>left<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">var</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">=</span>tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">function</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//分区操作，</span>        <span class="token keyword">var</span> pivotValue<span class="token operator">=</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token comment" spellcheck="true">//最右面设为标准</span>        <span class="token keyword">var</span> storeIndex<span class="token operator">=</span>left<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span>left<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>right<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>pivotValue<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>storeIndex<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                storeIndex<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>right<span class="token punctuation">,</span>storeIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> storeIndex<span class="token comment" spellcheck="true">//返回标杆元素的索引值</span>    <span class="token punctuation">}</span>    <span class="token keyword">function</span> <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">></span>right<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> storeIndex<span class="token operator">=</span><span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>left<span class="token punctuation">,</span>storeIndex<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>storeIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>时间复杂度O(nlogn)</p><h4 id="5、冒泡排序"><a href="#5、冒泡排序" class="headerlink" title="5、冒泡排序"></a>5、冒泡排序</h4><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cksmz9v6g30ib081jzl.gif" alt="冒泡排序"></p><ul><li><p>算法描述： </p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。 </li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 </li><li>针对所有的元素重复以上的步骤，除了最后一个。 </li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><pre class=" language-javascript"><code class="language-javascript"><span class="token number">5</span> <span class="token number">6</span> <span class="token number">3</span> <span class="token number">1</span> <span class="token number">8</span> <span class="token number">7</span> <span class="token number">2</span> <span class="token number">4</span><span class="token punctuation">[</span><span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">]</span> <span class="token number">3</span> <span class="token number">1</span> <span class="token number">8</span> <span class="token number">7</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token comment" spellcheck="true">//比较5和6</span><span class="token number">5</span> <span class="token punctuation">[</span><span class="token number">6</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token number">1</span> <span class="token number">8</span> <span class="token number">7</span> <span class="token number">2</span> <span class="token number">4</span><span class="token number">5</span> <span class="token number">3</span> <span class="token punctuation">[</span><span class="token number">6</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token number">8</span> <span class="token number">7</span> <span class="token number">2</span> <span class="token number">4</span><span class="token number">5</span> <span class="token number">3</span> <span class="token number">1</span> <span class="token punctuation">[</span><span class="token number">6</span> <span class="token number">8</span><span class="token punctuation">]</span> <span class="token number">7</span> <span class="token number">2</span> <span class="token number">4</span><span class="token number">5</span> <span class="token number">3</span> <span class="token number">1</span> <span class="token number">6</span> <span class="token punctuation">[</span><span class="token number">8</span> <span class="token number">7</span><span class="token punctuation">]</span> <span class="token number">2</span> <span class="token number">4</span><span class="token number">5</span> <span class="token number">3</span> <span class="token number">1</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token punctuation">[</span><span class="token number">8</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token number">4</span><span class="token number">5</span> <span class="token number">3</span> <span class="token number">1</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">2</span> <span class="token punctuation">[</span><span class="token number">8</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token number">5</span> <span class="token number">3</span> <span class="token number">1</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token number">8</span>  <span class="token comment" spellcheck="true">// 这样最后一个元素已经在正确位置，所以下一次开始时候就不需要再比较最后一个</span></code></pre></li><li><p>编程思路：</p><ul><li>外循环控制需要比较的元素，比如第一次排序后，最后一个元素就不需要比较了，内循环则负责两两元素比较，将元素放到正确位置上</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> len<span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span>len<span class="token number">-1</span><span class="token punctuation">;</span>i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">var</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>tmp            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><p>时间复杂度O(n^2)</p>]]></content>
      
      
      <categories>
          
          <category> 编程学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内存管理与链表</title>
      <link href="/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linked/"/>
      <url>/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linked/</url>
      
        <content type="html"><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="1、进程空间"><a href="#1、进程空间" class="headerlink" title="1、进程空间"></a>1、进程空间</h3><ul><li>程序，是经源码编译后的可执行文件，可执行文件可以多次被执行，比如我们可以多次打开 office。</li><li>而进程，是程序加载到内存后开始执行，至执行结束，这样一段时间概念，多次打开的wps,每打开一次都是一个进程，当我们每关闭一个 office，则表示该进程结束。</li><li>程序是静态概念，而进程动态/时间概念。</li></ul><h3 id="2、进程空间图示"><a href="#2、进程空间图示" class="headerlink" title="2、进程空间图示"></a>2、进程空间图示</h3><p>​    有了进程和程序的概念以后，我们再来看一下，程序被加载到内存以后内存空间布局是什么样的</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjvttmmtj30la0jdjsf.jpg" alt="进程空间图"></p><h3 id="3、栈内存-Stack"><a href="#3、栈内存-Stack" class="headerlink" title="3、栈内存(Stack)"></a>3、栈内存(Stack)</h3><ul><li>栈中存放任意类型的变量，但必须是 auto 类型修饰的，即自动类型的局部变量， 随用随开，用完即消。</li><li>内存的分配和销毁系统自动完成，不需要人工干预。</li><li>栈内存分配从地址大的开始分配。</li><li>栈的最大尺寸固定，超出则引起栈溢出 <ul><li>局部变量过多，过大 或 递归层数太多等就会导致栈溢出</li></ul></li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> ages<span class="token punctuation">[</span><span class="token number">10240</span><span class="token operator">*</span><span class="token number">10240</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 程序会崩溃, 栈溢出</span></code></pre><pre class=" language-c"><code class="language-c">include <span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token operator">></span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 存储在栈中, 内存地址从大到小 </span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;a = %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// &amp;a = 0060FEAC </span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;b = %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// &amp;b = 0060FEA8 </span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h3 id="4、堆内存-Heap"><a href="#4、堆内存-Heap" class="headerlink" title="4、堆内存(Heap)"></a>4、堆内存(Heap)</h3><ul><li>堆内存可以存放任意类型的数据，但需要自己申请与释放</li><li>堆大小，想像中的无穷大，但实际使用中，受限于实际内存的大小和内存是否连续性</li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10240</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不一定会崩溃</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span> </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span> </span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 存储在栈中, 内存地址从小到大 </span>    <span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p1 = %p\n"</span><span class="token punctuation">,</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// p1 = 00762F48 </span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p2 = %p\n"</span><span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// p2 = 00762F58 </span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h3 id="5、malloc函数"><a href="#5、malloc函数" class="headerlink" title="5、malloc函数"></a>5、malloc函数</h3><table><thead><tr><th>函数声明</th><th>void * malloc(size_t _Size);</th></tr></thead><tbody><tr><td>所在文件</td><td>stdlib.h</td></tr><tr><td>函数功能</td><td>申请堆内存空间并返回,所申请的空间并未初始化。</td></tr><tr><td>常见的初始化方法是</td><td>memset 字节初始化。</td></tr><tr><td>参数及返回解析</td><td></td></tr><tr><td>参数</td><td>size_t  _size 表示要申请的字符数</td></tr><tr><td>返回值</td><td>void *  成功返回非空指针指向申请的空间 ，失败返回 NULL</td></tr></tbody></table><ul><li>注意点：<ul><li>使用malloc函数必须导入一个头文件 stdlib.h；</li><li>通过malloc申请的空间默认存储的是垃圾数据，也就是系统不会帮我们初始化；</li><li>利用malloc函数分配空间，必须是连续的，也就是在对内存中分配内存空间必须是连续的；</li><li>一般情况下。malloc和memset函数结合起来使用。   </li></ul></li><li><strong>memset函数</strong></li></ul><table><thead><tr><th>函数声明</th><th style="text-align:left">memset(void *_Dst,int_Val,size_t _Size)</th></tr></thead><tbody><tr><td>所在文件</td><td style="text-align:left">string.h</td></tr><tr><td>函数功能</td><td style="text-align:left">专门用于初始化一块内存空间</td></tr><tr><td>第一个参数</td><td style="text-align:left">需要初始化的内存地址</td></tr><tr><td>第二个参数</td><td style="text-align:left">需要初始化的值</td></tr><tr><td>第个参数</td><td style="text-align:left">需要初始化对少个字节</td></tr></tbody></table><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*     * malloc     * 第一个参数: 需要申请多少个字节空间     * 返回值类型: void *     */</span>     <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p = %i\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 保存垃圾数据</span>    <span class="token function">memset</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 对申请的内存空间进行初始化</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p = %i\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化为0</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//(int *)强制类型转换</span><span class="token comment" spellcheck="true">//malloc函数返回的void *，而我们开辟的是4个字节，正好是int类型</span><span class="token comment" spellcheck="true">//所以最好将void *转换为int *，因为只有指针类型int类型</span><span class="token comment" spellcheck="true">//将来操作这块内存的时候，我们才知道应该操作多少个字节</span></code></pre><h3 id="6、free函数"><a href="#6、free函数" class="headerlink" title="6、free函数"></a>6、free函数</h3><ul><li>注意: 通过malloc申请的存储空间一定要释放, 所以malloc和free函数总是成对出现</li></ul><table><thead><tr><th>函数声明</th><th>void free(void *p);</th></tr></thead><tbody><tr><td>所在文件</td><td>stdlib.h</td></tr><tr><td>函数功能</td><td>释放申请的堆内存</td></tr><tr><td>参数及返回解析</td><td></td></tr><tr><td>参数</td><td>void*   p 指向手动申请的空间</td></tr><tr><td>返回值</td><td>void    无返回</td></tr></tbody></table><ul><li>free函数，当我们只传递了内存的地址，系统如何知道应该释放多少个字节的存储空间？（<strong>面试题</strong>）<ul><li>在利用malloc分配的时候，系统就偷偷摸摸的保存了该指针对用的大小</li></ul></li></ul><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1.申请4个字节存储空间</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2.初始化4个字节存储空间为0</span>    <span class="token function">memset</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3.释放申请的存储空间</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="7、calloc函数"><a href="#7、calloc函数" class="headerlink" title="7、calloc函数"></a>7、calloc函数</h3><ul><li>calloc函数：就是对malloc函数的封装，一般用于开辟<strong>数组</strong>的存储空间。</li></ul><table><thead><tr><th>函数声明</th><th>void *calloc(size_t nmemb, size_t size);</th></tr></thead><tbody><tr><td>所在文件</td><td>stdlib.h</td></tr><tr><td>函数功能</td><td>申请堆内存空间并返回，所申请的空间，自动清零</td></tr><tr><td>参数及返回解析</td><td></td></tr><tr><td>参数</td><td>size_t     nmemb 所需内存单元数量</td></tr><tr><td>参数</td><td>size_t size    内存单元字节数量</td></tr><tr><td>返回值</td><td>void * 成功返回非空指针指向申请的空间 ，失败返回 NULL</td></tr></tbody></table><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*    // 1.申请3块4个字节存储空间    int *p = (int *)malloc(sizeof(int) * 3);    // 2.使用申请好的3块存储空间    p[0] = 1;    p[1] = 3;    p[2] = 5;    printf("p[0] = %i\n", p[0]);    printf("p[1] = %i\n", p[1]);    printf("p[2] = %i\n", p[2]);    // 3.释放空间    free(p);    */</span>    <span class="token comment" spellcheck="true">// 1.申请3块4个字节存储空间</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2.使用申请好的3块存储空间</span>    p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p[0] = %i\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p[1] = %i\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p[2] = %i\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3.释放空间</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="8、realloc函数"><a href="#8、realloc函数" class="headerlink" title="8、realloc函数"></a>8、realloc函数</h3><table><thead><tr><th>函数声明</th><th>void <em>realloc(void </em>ptr, size_t size);</th></tr></thead><tbody><tr><td>所在文件</td><td>stdlib.h</td></tr><tr><td>函数功能</td><td>扩容(缩小)原有内存的大小。通常用于扩容，缩小会会导致内存缩去的部分数据丢失。</td></tr><tr><td>参数及返回解析</td><td></td></tr><tr><td>参数</td><td>void * ptr 表示待扩容(缩小)的指针， ptr 为之前用 malloc 或者 calloc 分配的内存地址。</td></tr><tr><td>参数</td><td>size_t size 表示扩容(缩小)后内存的大小。</td></tr><tr><td>返回值</td><td>void* 成功返回非空指针指向申请的空间 ，失败返回 NULL。</td></tr></tbody></table><ul><li>注意点: <ul><li>若参数ptr==NULL，则该函数等同于 malloc</li><li>返回的指针，可能与 ptr 的值相同，也有可能不同。若相同，则说明在原空间后面申请，否则，则可能后续空间不足，重新申请的新的连续空间，原数据拷贝到新空间， 原有空间自动释放</li></ul></li></ul><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1.申请4个字节存储空间</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token function">realloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 此时等同于malloc</span>    <span class="token comment" spellcheck="true">// 2.使用申请好的空间</span>    <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*p = %i\n"</span><span class="token punctuation">,</span>  <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3.释放空间</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1.申请4个字节存储空间</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p = %p\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果能在传入存储空间地址后面扩容, 返回传入存储空间地址</span>    <span class="token comment" spellcheck="true">// 如果不能在传入存储空间地址后面扩容, 返回一个新的存储空间地址</span>    p <span class="token operator">=</span> <span class="token function">realloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p = %p\n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2.使用申请好的空间</span>    <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*p = %i\n"</span><span class="token punctuation">,</span>  <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3.释放空间</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><hr><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul><li><p>链表实现了，内存零碎数据的有效组织。比如，当我们用 malloc 来进行内存申请的时候，当内存足够，但是由于碎片太多，没有连续内存时，只能以申请失败而告终，而用链表这种数据结构来组织数据，就可以解决上类问题。</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjwhyhdyj30rs0c9n5s.jpg" alt="l链表"></p></li></ul><h3 id="1、静态链表"><a href="#1、静态链表" class="headerlink" title="1、静态链表"></a>1、静态链表</h3><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjwr4zn1j30rs08bq3s.jpg" alt="静态链表"></p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token comment" spellcheck="true">// 1.定义链表节点</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> node<span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> node <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span>Node<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 2.创建链表节点</span>    Node a<span class="token punctuation">;</span>    Node b<span class="token punctuation">;</span>    Node c<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3.初始化节点数据</span>    a<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    b<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    c<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 4.链接节点</span>    a<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>    b<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span>    c<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*     *如果指针没有值，那么就可以赋值为NULL，明确告诉系统该指针没有值     *如果一个指针没有值，也没有赋值为NULL，那么这个指针就是一个野指针     *注意点：一定不要操作没有值的指针和野指针    */</span>    <span class="token comment" spellcheck="true">// 5.创建链表头</span>    Node <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 6.使用链表</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> currentData <span class="token operator">=</span> head<span class="token operator">-></span>data<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"currentData = %i\n"</span><span class="token punctuation">,</span> currentData<span class="token punctuation">)</span><span class="token punctuation">;</span>        head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="2、动态链表"><a href="#2、动态链表" class="headerlink" title="2、动态链表"></a>2、动态链表</h3><ul><li>静态链表的意义不是很大，主要原因，数据存储在栈上，栈的存储空间有限，不能动态分配。所以链表要实现存储的自由，要动态的申请堆里的空间。</li><li>有一个点要说清楚，我们的实现的链表是带头节点。至于，为什么带头节点，需等大家对链表有个整体的的认知以后，再来体会，会更有意义。</li></ul><h4 id="2-1、空链表"><a href="#2-1、空链表" class="headerlink" title="2.1、空链表"></a>2.1、空链表</h4><ul><li><p>头指针带了一个空链表节点, 空链表节点中的next指向NULL</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjx8qs7fj30d9092glk.jpg" alt="空链表"></p></li></ul><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token comment" spellcheck="true">// 1.定义链表节点</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> node<span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> node <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span>Node<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Node <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token function">createList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 创建空链表</span>Node <span class="token operator">*</span><span class="token function">createList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1.创建一个节点</span>    <span class="token comment" spellcheck="true">//注意点：malloc有可能分配失败</span>    Node <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//直接退出程序</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 2.设置下一个节点为NULL</span>    node<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3.返回创建好的节点</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjxk861lj316k0lo19y.jpg" alt="空链表内存分配图"></p><h4 id="2-2、非空链表"><a href="#2-2、非空链表" class="headerlink" title="2.2、非空链表"></a>2.2、非空链表</h4><ul><li><p>头指针带了一个非空节点, 最后一个节点中的next指向NULL</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjxtkk08j30rs084q3z.jpg" alt="非空链表"></p></li></ul><h4 id="2-3、动态链表头插法"><a href="#2-3、动态链表头插法" class="headerlink" title="2.3、动态链表头插法"></a>2.3、动态链表头插法</h4><ul><li>1.让新节点的下一个节点等于头结点的下一个节点</li><li>2.让头节点的下一个节点等于新节点</li></ul><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token comment" spellcheck="true">// 1.定义链表节点</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> node<span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> node <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span>Node<span class="token punctuation">;</span>Node <span class="token operator">*</span><span class="token function">createList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">printNodeList</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Node <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token function">createList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printNodeList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * @brief createList 创建链表 * @return  创建好的链表 */</span>Node <span class="token operator">*</span><span class="token function">createList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1.创建头节点</span>    Node <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    head<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2.接收用户输入数据</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入节点数据\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%i"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3.通过循环创建其它节点</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>num <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 3.1创建一个新的节点</span>        Node <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cur<span class="token operator">-></span>data <span class="token operator">=</span> num<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3.2让新节点的下一个节点指向头节点的下一个节点</span>        cur<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3.3让头节点的下一个节点指向新节点</span>        head<span class="token operator">-></span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3.4再次接收用户输入数据</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%i"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 3.返回创建好的节点</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * @brief printNodeList 遍历链表 * @param node 链表指针头 */</span><span class="token keyword">void</span> <span class="token function">printNodeList</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>    Node <span class="token operator">*</span>head <span class="token operator">=</span> node<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> currentData <span class="token operator">=</span> head<span class="token operator">-></span>data<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"currentData = %i\n"</span><span class="token punctuation">,</span> currentData<span class="token punctuation">)</span><span class="token punctuation">;</span>        head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-4、动态链表尾插法"><a href="#2-4、动态链表尾插法" class="headerlink" title="2.4、动态链表尾插法"></a>2.4、动态链表尾插法</h4><ul><li>1.定义变量记录新节点的上一个节点；</li><li>2.将新节点添加到上一个节点后面；</li><li>3.让新节点成为下一个节点的上一个节点。</li><li>规律：新的节点永远都是插入到了头节点的后面。</li></ul><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//1、让新节点的下一个节点等于头节点的下一个节点</span><span class="token comment" spellcheck="true">//2、让头节点的下一个节点等于新节点</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token comment" spellcheck="true">// 1.定义链表节点</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> node<span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> node <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span>Node<span class="token punctuation">;</span>Node <span class="token operator">*</span><span class="token function">createList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">printNodeList</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Node <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token function">createList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printNodeList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * @brief createList 创建链表 * @return  创建好的链表 */</span>Node <span class="token operator">*</span><span class="token function">createList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1.创建头节点</span>    Node <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    head<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2.接收用户输入数据</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入节点数据\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%i"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3.通过循环创建其它节点</span>    <span class="token comment" spellcheck="true">// 定义变量记录上一个节点</span>    Node <span class="token operator">*</span>pre <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>num <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 3.1创建一个新的节点</span>        Node <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cur<span class="token operator">-></span>data <span class="token operator">=</span> num<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3.2让新节点链接到上一个节点后面</span>        pre<span class="token operator">-></span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3.3当前节点下一个节点等于NULL</span>        cur<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3.4让当前节点编程下一个节点的上一个节点</span>        pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3.5再次接收用户输入数据</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%i"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 3.返回创建好的节点</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * @brief printNodeList 遍历链表 * @param node 链表指针头 */</span><span class="token keyword">void</span> <span class="token function">printNodeList</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>    Node <span class="token operator">*</span>head <span class="token operator">=</span> node<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> currentData <span class="token operator">=</span> head<span class="token operator">-></span>data<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"currentData = %i\n"</span><span class="token punctuation">,</span> currentData<span class="token punctuation">)</span><span class="token punctuation">;</span>        head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-3、动态链优化"><a href="#2-3、动态链优化" class="headerlink" title="2.3、动态链优化"></a>2.3、动态链优化</h4><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token comment" spellcheck="true">// 1.定义链表节点</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> node<span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> node <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span>Node<span class="token punctuation">;</span>Node <span class="token operator">*</span><span class="token function">createList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">printNodeList</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">insertNode1</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">insertNode2</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1.创建一个空链表</span>    Node <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token function">createList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2.往空链表中插入数据</span>    <span class="token function">insertNode1</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">insertNode1</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">insertNode1</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printNodeList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * @brief createList 创建空链表 * @return  创建好的空链表 */</span>Node <span class="token operator">*</span><span class="token function">createList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1.创建头节点</span>    Node <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    head<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3.返回创建好的节点</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * @brief insertNode1 尾插法插入节点 * @param head 需要插入的头指针 * @param data 需要插入的数据 * @return  插入之后的链表 */</span><span class="token keyword">void</span> <span class="token function">insertNode1</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1.定义变量记录最后一个节点</span>    Node <span class="token operator">*</span>pre <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> pre<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        pre <span class="token operator">=</span> pre<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 2.创建一个新的节点</span>    Node <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cur<span class="token operator">-></span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3.让新节点链接到上一个节点后面</span>    pre<span class="token operator">-></span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 4.当前节点下一个节点等于NULL</span>    cur<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 5.让当前节点编程下一个节点的上一个节点</span>    pre <span class="token operator">=</span> cur<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * @brief insertNode1 头插法插入节点 * @param head 需要插入的头指针 * @param data 需要插入的数据 * @return  插入之后的链表 */</span><span class="token keyword">void</span> <span class="token function">insertNode2</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1.创建一个新的节点</span>    Node <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cur<span class="token operator">-></span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2.让新节点的下一个节点指向头节点的下一个节点</span>    cur<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3.让头节点的下一个节点指向新节点</span>    head<span class="token operator">-></span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * @brief printNodeList 遍历链表 * @param node 链表指针头 */</span><span class="token keyword">void</span> <span class="token function">printNodeList</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>    Node <span class="token operator">*</span>head <span class="token operator">=</span> node<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> currentData <span class="token operator">=</span> head<span class="token operator">-></span>data<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"currentData = %i\n"</span><span class="token punctuation">,</span> currentData<span class="token punctuation">)</span><span class="token punctuation">;</span>        head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="3、链表销毁"><a href="#3、链表销毁" class="headerlink" title="3、链表销毁"></a>3、链表销毁</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief destroyList 销毁链表 * @param head 链表头指针 */</span><span class="token keyword">void</span> <span class="token function">destroyList</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>    Node <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cur <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        head <span class="token operator">=</span> cur<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="4、链表长度计算"><a href="#4、链表长度计算" class="headerlink" title="4、链表长度计算"></a>4、链表长度计算</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief listLength 计算链表长度 * @param head 链表头指针 * @return 链表长度 */</span><span class="token keyword">int</span> <span class="token function">listLength</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>       count<span class="token operator">++</span><span class="token punctuation">;</span>       head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="5、链表查找"><a href="#5、链表查找" class="headerlink" title="5、链表查找"></a>5、链表查找</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief searchList 查找指定节点 * @param head 链表头指针 * @param key 需要查找的值 * @return */</span>Node <span class="token operator">*</span><span class="token function">searchList</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//注意点：头节点不需要查找</span>    head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//判断当前节点保存的值是否是要查找的值</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">-></span>data <span class="token operator">==</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="6、链表删除"><a href="#6、链表删除" class="headerlink" title="6、链表删除"></a>6、链表删除</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">deleteNodeList</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>head<span class="token punctuation">,</span> Node <span class="token operator">*</span>find<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//1 找到需要删除节点的上一个节点</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next <span class="token operator">!=</span> find<span class="token punctuation">)</span><span class="token punctuation">{</span>        head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 2 将删除节点的上一个节点的next改为删除节点的下一个节点</span>    head<span class="token operator">-></span>next <span class="token operator">=</span> find<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3 删除节点</span>    <span class="token function">free</span><span class="token punctuation">(</span>find<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="7、作业"><a href="#7、作业" class="headerlink" title="7、作业"></a>7、作业</h3><ul><li>给链表排序</li></ul><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief bubbleSort 对链表进行排序 * @param head 链表头指针 */</span><span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1.计算链表长度</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2.定义变量记录前后节点</span>    Node <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 3.相邻元素进行比较, 进行冒泡排序</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cur <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%i, %i\n"</span><span class="token punctuation">,</span> cur<span class="token operator">-></span>data<span class="token punctuation">,</span> cur<span class="token operator">-></span>next<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>data<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token punctuation">(</span>cur<span class="token operator">-></span>next<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> cur<span class="token operator">-></span>data<span class="token punctuation">;</span>                cur<span class="token operator">-></span>data <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token operator">-></span>data<span class="token punctuation">;</span>                cur<span class="token operator">-></span>next<span class="token operator">-></span>data <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * @brief sortList 对链表进行排序 * @param head 链表头指针 */</span><span class="token keyword">void</span> <span class="token function">sortList</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 0.计算链表长度</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 1.定义变量保存前后两个节点</span>    Node <span class="token operator">*</span>sh<span class="token punctuation">,</span> <span class="token operator">*</span>pre<span class="token punctuation">,</span> <span class="token operator">*</span>cur<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        sh <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 头节点</span>        pre <span class="token operator">=</span> sh<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 第一个节点</span>        cur <span class="token operator">=</span> pre<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 第二个节点</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>pre<span class="token operator">-></span>data <span class="token operator">></span> cur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 交换节点位置</span>                sh<span class="token operator">-></span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>                pre<span class="token operator">-></span>next <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>                cur<span class="token operator">-></span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 恢复节点名称</span>                Node <span class="token operator">*</span>temp <span class="token operator">=</span> pre<span class="token punctuation">;</span>                pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>                cur <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 让所有节点往后移动</span>            sh <span class="token operator">=</span> sh<span class="token operator">-></span>next<span class="token punctuation">;</span>            pre <span class="token operator">=</span> pre<span class="token operator">-></span>next<span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>链表反转</li></ul><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/** * @brief reverseList 反转链表 * @param head 链表头指针 */</span><span class="token keyword">void</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1.将链表一分为二</span>    Node <span class="token operator">*</span>pre<span class="token punctuation">,</span> <span class="token operator">*</span>cur<span class="token punctuation">;</span>    pre <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    head<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2.重新插入节点</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">{</span>        cur <span class="token operator">=</span> pre<span class="token operator">-></span>next<span class="token punctuation">;</span>        pre<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>        head<span class="token operator">-></span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>        pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><p><strong><em>本文仅作为个人的随身读书笔记收集，没有用于任何商业盈利范畴。如若有侵犯源作者的著作权，请联系本人（立马撤文）<a href="mailto:mstarzheng@foxmail.com" target="_blank" rel="noopener">mstarzheng@foxmail.com</a></em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>经典算法篇</title>
      <link href="/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/algorithm/"/>
      <url>/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/algorithm/</url>
      
        <content type="html"><![CDATA[<h2 id="经典算法篇"><a href="#经典算法篇" class="headerlink" title="经典算法篇"></a>经典算法篇</h2><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>​    计数排序是一个非基于比较的排序算法，该算法于1954年由 Harold H. Seward 提出。它的优势在于在对一定范围内的整数排序时，快于任何比较排序算法。</p><ul><li><strong>排序思想</strong><ul><li>1.找出待排序数组最大值</li><li>2.定义一个索引最大值为待排序数组最大值的数组</li><li>3.遍历待排序数组, 将待排序数组遍历到的值作新数组索引</li><li>4.在新数组对应索引存储值原有基础上+1    </li></ul></li></ul><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjme18qbj30g60960uv.jpg" alt="计数排序"></p><p><strong>代码实现</strong></p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//待排序的数组</span>    <span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//用于保存排序数组</span>    <span class="token keyword">int</span> newNums<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//计算数组的长度</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//遍历数组</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//取出待排序数组当前值</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将待排序数组当前值作为排序数组索引</span>        <span class="token comment" spellcheck="true">// 将用于排序数组对应索引原有值+1</span>        newNums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//计算排序数组的长度</span>    <span class="token keyword">int</span> len2 <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>newNums<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>newNums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输出排序数组索引，就是排序之后结果</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> len2<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>newNums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%i\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>​    选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素,存放到排序序列的起始位置,然后,再从剩余未排序元素中继续寻找最小元素,然后放到排序序列末尾。以此类推,直到所有元素均排序完毕。</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjmzanrbg30mj06w7l2.gif" alt="选择排序"></p><ul><li><p><strong>排序思想</strong></p><ul><li>假设按照升序排序</li><li>1.用第0个元素和后面所有元素依次比较</li><li>2.判断第0个元素是否大于当前被比较元素, 一旦小于就交换位置</li><li>3.第0个元素和后续所有元素比较完成后, 第0个元素就是最小值</li><li>4.排除第0个元素, 用第1个元素重复1~3操作, 比较完成后第1个元素就是倒数第二小的值</li><li>以此类推, 直到当前元素没有可比较的元素, 排序完成</li></ul></li><li><p><strong>代码实现</strong></p></li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">selectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> numbers<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 外循环为什么要-1?</span>    <span class="token comment" spellcheck="true">// 最后一位不用比较, 也没有下一位和它比较, 否则会出现错误访问</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>j <span class="token operator">&lt;</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> numbers<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//  2.一旦发现小于就交换位置</span>                <span class="token function">swapEle</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 交换两个元素的值, i/j需要交换的索引</span><span class="token keyword">void</span> <span class="token function">swapEle</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>​    冒泡排序(Bubble Sort)是一种简单的排序算法。它重复 地走访过要排序的数列,一次比较两个元素,如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换,也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjnh5ttmg30my075wqv.gif" alt="冒泡排序"></p><ul><li><p><strong>排序思想</strong></p><ul><li>假设按照升序排序</li><li>1.从第0个元素开始, 每次都用相邻两个元素进行比较</li><li>2.一旦发现后面一个元素小于前面一个元素就交换位置</li><li>3.经过一轮比较之后最后一个元素就是最大值</li><li>4.排除最后一个元素, 以此类推, 每次比较完成之后最大值都会出现再被比较所有元素的最后</li><li>直到当前元素没有可比较的元素, 排序完成</li></ul></li><li><p><strong>代码实现</strong></p></li></ul><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 冒泡排序</span><span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> numbers<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// -1防止`角标越界`: 访问到了不属于自己的索引</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">//  1.用当前元素和相邻元素比较</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> numbers<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//  2.一旦发现小于就交换位置</span>                <span class="token function">swapEle</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 交换两个元素的值, i/j需要交换的索引</span><span class="token keyword">void</span> <span class="token function">swapEle</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>​    插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjnt7mzfg30mj0e113f.gif" alt="插入排序"></p><ul><li><p><strong>排序思路:</strong></p><ul><li>假设按照升序排序</li><li>1.从索引为1的元素开始向前比较, 一旦前面一个元素大于自己就让前面的元素先后移动</li><li>2.直到没有可比较元素或者前面的元素小于自己的时候, 就将自己插入到当前空出来的位置</li></ul></li><li><p><strong>代码实现：</strong></p></li></ul><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//方法一：</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//待排序的数组</span>    <span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//0、计算待排序数组的长度</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//1、从第一元素开始依次取出所有用于比较的元素</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//2、取出用于比较的元素</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//3、保存前面一个元素的索引</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">//4、判断元素是否小于前面一个元素</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//小于</span>                 <span class="token comment" spellcheck="true">//5、让前面一个元素往后移动一位</span>                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//大于</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//6、将元素插入到空出来的位置</span>        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//方法二：</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 待排序数组</span>    <span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 0.计算待排序数组长度</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  1.从第一个元素开始依次取出所有用于比较元素</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 2.遍历取出前面元素进行比较</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 3.如果前面一个元素大于当前元素,就交换位置</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span> <span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>​    1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjo91kdbg30ih082h71.gif" alt="希尔排序"></p><ul><li><p><strong>排序思路</strong></p><ul><li>1.希尔排序可以理解为插入排序的升级版, 先将待排序数组按照指定步长划分为几个小数组</li><li>2.利用插入排序对小数组进行排序, 然后将几个排序的小数组重新合并为原始数组</li><li>3.重复上述操作, 直到步长为1时,再利用插入排序排序即可</li></ul></li><li><p><strong>代码实现</strong></p></li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 待排序数组</span>    <span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 0.计算待排序数组长度</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 2.计算步长</span>    <span class="token keyword">int</span> gap <span class="token operator">=</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">do</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//  1.从第一个元素开始依次取出所有用于比较元素</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 2.遍历取出前面元素进行比较</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>j <span class="token operator">-</span> gap<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%i > %i\n"</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 3.如果前面一个元素大于当前元素,就交换位置</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span><span class="token punctuation">;</span>                    nums<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 每个小数组排序完成, 重新计算步长</span>        gap <span class="token operator">=</span> gap <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>gap <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><ul><li><p><strong>基本思路</strong></p><ul><li>在有序表中,取中间元素作为比较对象,若给定值与中间元素的要查找的数相等,则查找成功;若给定值小于中间元素的要查找的数,则在中间元素的左半区继续查找;</li><li>若给定值大于中间元素的要查找的数,则在中间元素的右半区继续查找。不断重复上述查找过 程,直到查找成功,或所查找的区域无数据元素,查找失败</li></ul></li><li><p><strong>实现步骤</strong></p><ul><li>①在有序表中,取中间元素作为比较对象,若给定值与中间元素的要查找的数相等,则查找成功;</li><li>②若给定值小于中间元素的要查找的数,则在中间元素的左半区继续查找;</li><li>③若给定值大于中间元素的要查找的数,则在中间元素的右半区继续查找。</li><li>④不断重复上述查找过 程,直到查找成功,或所查找的区域无数据元素,查找失败。</li></ul></li></ul><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjonktglj30dn09t78l.jpg" alt="折半查找"></p><ul><li><strong>代码实现</strong></li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">findKey</span><span class="token punctuation">(</span><span class="token keyword">int</span> values<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 定义一个变量记录最小索引</span>    <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 定义一个变量记录最大索引</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 定义一个变量记录中间索引</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>min <span class="token operator">+</span> max<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.5</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>min <span class="token operator">&lt;=</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果mid对应的值 大于 key, 那么max要变小</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>values<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>            max <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果mid对应的值 小于 key, 那么min要变</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>values<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>            min <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 修改完min/max之后, 重新计算mid的值</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span>min <span class="token operator">+</span> max<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.5</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><hr><p><strong><em>本文仅作为个人的随身读书笔记收集，没有用于任何商业盈利范畴。如若有侵犯源作者的著作权，请联系本人（立马撤文）<a href="mailto:mstarzheng@foxmail.com" target="_blank" rel="noopener">mstarzheng@foxmail.com</a></em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> Typora </tag>
            
            <tag> Markcown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我问佛</title>
      <link href="/%E6%96%87%E5%AD%97%E7%9A%84%E9%AD%85%E5%8A%9B/buddha/"/>
      <url>/%E6%96%87%E5%AD%97%E7%9A%84%E9%AD%85%E5%8A%9B/buddha/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjqc4mc4j30hs0hsjsa.jpg" alt=""></p><center><br>我问佛<br>为何不给世间所有女子羞花闭月的容颜？<br>佛曰：<br>“那只是昙花一现，<br>用来蒙蔽世俗的眼。<br>没有什么美，<br>可以抵过一颗纯洁仁爱的心。<br>我把它赐给了每一个女子，<br>可有人让它蒙上了灰”。<br></center><br><a id="more"></a><br><center><br>我问佛<br>世间为何有那么多的遗憾？<br>佛曰：<br>“这是一个婆娑世界，<br>婆娑既遗憾。<br>没有遗憾，<br>给你再多的幸福也不会体会快乐”。<br></center><center><br>我问佛<br>如何让人们的心不再感到孤单？<br>佛曰：<br>“每一颗心生来就孤单而残缺的，<br>多数带着这种残缺度过一生。<br>只因与能使他圆满的另一半相遇时，<br>不是疏忽错过，<br>就是已失去了拥有她的资格”。<br></center><center><br>我问佛<br>如果遇到可以爱的人，<br>却又不怕不能把握该怎么办？<br>佛曰：<br>“留人间多少爱，<br>迎浮世千重变。<br>和有情人做快乐事，<br>别问是劫是缘”。<br></center><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjppv6voj30et08cmxe.jpg" alt=""></p><center><br>我问佛<br>如何才能如你般睿智？<br>佛曰：<br>“佛是过来人，<br>人是未来佛。<br>佛把世间万物分为十阶:<br>佛、菩萨、生闻、圆觉、天、<br>阿修罗、人、畜生、恶鬼、地狱。<br>天、阿修罗、人、畜生、恶鬼、地狱，<br>为六道众生。<br>六道众生要经历因果轮回，<br>从中体验痛苦，<br>在体验痛苦的过程中。<br>只有参透生命的真谛，<br>才能得到永生。<br>凤凰，涅槃”。<br></center><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjqm2muuj30hb0b9weh.jpg" alt=""></p><center><br>佛曰：“人生有八苦:<br>生老、病死、爱别离、怨长久、求不得、放不下”。<br><br>佛曰：“命有几遭，相由心生，世间万物皆是画像。<br>心不动，万物皆不动;心不变，万物皆不变”。<br><br>佛说：”坐一禅，行一禅；一花一世界，一叶一如来。<br>春来花自清，秋至叶飘零。<br>无穷般若，心自在;雨墨动静，题自然”。<br><br>佛说：“万法皆生，皆系缘分。<br>偶然地相遇，蓦然地回首。<br>注定彼此的一生，只为眼神交汇的刹那。<br>缘起既灭，缘生一空，我也曾如你般天真。<br>佛门中说，一个人悟道有三阶段：看破、放下、自在。<br>的确一个人必须放下，才能得到自在”。<br></center><center><br>我问佛<br>为什么总是在我悲伤的时候下雪？<br>佛说：<br>“冬天就要过去，<br>留点记忆”。<br></center><center><br>我问佛<br>每次下雪都是我不在意的夜晚？<br>佛说：<br>“不经意的时候人们总是错过真正的美丽”。<br></center><center><br>我问佛<br>那过几天还下不下雪？<br>佛说：<br>“不要只盯着这个季节，<br>错过了今冬”。<br></center><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjquubifj30jg0bo750.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 文字的魅力 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桂林电子科技大学 </tag>
            
            <tag> mstar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七夕情话</title>
      <link href="/Love/%E4%B8%83%E5%A4%95/"/>
      <url>/Love/%E4%B8%83%E5%A4%95/</url>
      
        <content type="html"><![CDATA[<center>我们的故事–初雪之恋</center><center><br>那天<br>初雪悄悄<br>降临人间<br><br>小小的雪花<br>好像无数<br>蹁跹飞舞的<br>白色蝴蝶<br><br>你牵着我的手<br>在雪中慢慢走<br><br>你说<br>这样一直走<br>不知不觉就白了头<br><br>那夜<br>大雪纷飞<br>打湿了我的眼<br><br>小小的手<br>被牢牢地包在掌心<br>所有的不安<br>顷刻间<br>化成白雪<br><br>曾经最怕<br>下雪的冬夜<br>可是<br>从那以后<br>我才知道<br><br>原来<br>再冷的雪<br>在爱人的怀里也能化茧成蝶<br></center><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ckpsst98j30rs0ku1kx.jpg" alt=""></p><center>择一城终老，遇一人白首</center>]]></content>
      
      
      <categories>
          
          <category> Love </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OC的类</title>
      <link href="/Objective-C%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/OC-class/"/>
      <url>/Objective-C%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/OC-class/</url>
      
        <content type="html"><![CDATA[<p><hr></p><h2 id="一、语法简介"><a href="#一、语法简介" class="headerlink" title="一、语法简介"></a>一、语法简介</h2><h3 id="1-类"><a href="#1-类" class="headerlink" title="1.类"></a>1.类</h3><p>在OC中，一般用2个文件来描述一个类：</p><ul><li><font color="red">.h</font>：类的<font color="red">声明</font>文件，用于声明成员变量、方法。类的声明使用关键字<font color="red">@interface和@end。</font></li></ul><p>注意：.h中的方法只是做一个声明，并不对方法进行实现。也就是说，只是说明一下方法名、方法的返回值类型、方法接收的参数类型而已，并不会编写方法内部的代码。</p><ul><li><font color="red">.m</font>：类的<font color="red">实现</font>文件，用于实现.h中声明的方法。类的实现使用关键字<font color="red">@implementation和@end</font>。</li></ul><h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2.方法"></a>2.方法</h3><p>1&gt; 方法的声明和实现，都必须以 <font color="red">+ 或者 <font color="red">- 开头</font></font></p><ul><li><font color="red"> <strong> + </strong></font>表示<font color="red">类</font>方法(<font color="red">静态</font>方法)</li><li><font color="red"><strong> - </strong></font>表示<font color="red">对象</font>方法(<font color="red">动态</font>方法)</li></ul><p>2&gt; 在.h中声明的所有方法作用域都是public类型，不能更改</p><h3 id="3-成员变量"><a href="#3-成员变量" class="headerlink" title="3.成员变量"></a>3.成员变量</h3><p>成员变量的常用作用域有3种：</p><ul><li>@<font color="red">public</font> 全局都可以访问</li><li>@<font color="red">protected</font> 只能在类内部和子类中访问</li><li>@<font color="red">private</font> 只能在类内部访问</li></ul><p><hr></p><h2 id="二、创建对象"><a href="#二、创建对象" class="headerlink" title="二、创建对象"></a>二、创建对象</h2><p>由于OC程序的入口点是main函数，所以在main.m文件中演示Student类的使用。<br>先上完整代码</p><pre class=" language-objective-c"><code class="language-objective-c">#import <Foundation/Foundation.h>#import "Student.h"int main(int argc, const char * argv[]){   @autoreleasepool {        Student *stu = [[Student alloc] init];         [stu release];     }     return 0;}</code></pre><h3 id="1-包含Student-h"><a href="#1-包含Student-h" class="headerlink" title="1.包含Student.h"></a>1.包含Student.h</h3><p>因为要用到Student这个类，所以在第2行包含了它的头文件</p><blockquote><p>#import “Student.h”</p></blockquote><h3 id="2-创建对象"><a href="#2-创建对象" class="headerlink" title="2.创建对象"></a>2.创建对象</h3><p>1&gt; 在Java中是使用关键字new来创建对象，比如new Student()，其实这句代码做了2件事：</p><ul><li>给对象分配存储空间</li><li>调用Student的构造方法进行初始化</li></ul><p>2&gt; 在OC中创建对象也需要按顺序做上面所述的2件事</p><p>1)调用Student类的静态方法alloc分配存储空间</p><blockquote><p>Student *stu = [Student <font color="blue">alloc<font>];</font></font></p></blockquote><ul><li>OC是方法调用是用中括号[ ]，方法调用者写在括号左侧，方法名写在括号右侧，中间留点空格。因此上面是调用了Student类的静态方法alloc。</li><li>上面调用的alloc方法会返回分配好内存的Student对象，在等号左边用了一个指向Student类型的<font color="blue">指针变量</font>stu来接收这个对象，注意stu左边的<font color="red"><em></em></font>号。所有OC对象都是用指针变量来接收的，如果你不了解指针，你记住下面这点就行了：利用类名定义一个变量时，类名后面一定要带个<font color="red"></font>号。</li><li>alloc方法是这样声明的：</li></ul><blockquote><p>+(<font color="blue">id<font>)alloc;</font></font></p></blockquote><p>可以看到，它的返回值类型是id，这个id代表任何指针类型，你可以暂时理解为：id可以代表<font color="red">任何OC对象</font>，类似于NSObject *。</p><p>2)调用Student对象的构造方法init进行初始化</p><p>前面调用alloc方法返回的Student对象stu是不能正常使用的，因为仅仅是分配了内存，并没有进行初始化，接下来调用对象的init方法进行初始化</p><blockquote><p>stu = [stu <font color="blue">init<font>];</font></font></p></blockquote><p>看清楚了，由于init是动态方法，所以这里使用stu变量来调用，并不是使用类名来调用。init会返回已经初始化完毕的对象，再次赋值给了stu变量。这时候的Student对象stu才能正常使用。</p><p>3)其实，我们最常见的做法是将alloc和init连起来使用：</p><blockquote><p>Student *stu = [[Student <font color="blue">alloc] init<font>];</font></font></p></blockquote><p>相信有面向对象开发经验的你一眼就能看懂了，在main.m完整代码的第7行。</p><p><hr></p><h2 id="三、代码解析"><a href="#三、代码解析" class="headerlink" title="三、代码解析"></a>三、代码解析</h2><h3 id="1、如何编写类的声明"><a href="#1、如何编写类的声明" class="headerlink" title="1、如何编写类的声明"></a>1、如何编写类的声明</h3><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck5yrg3fj309i01n0so.jpg" alt=""></p><ul><li><p>以<font color="red">@interface </font>开头，以<font color="red">@end</font>结尾，然后再用<font color="red">class name</font>对应的地方写上事物名称，也就是类名即可<br><font color="red">注意</font>：类名的首字符必须大写<br>声明一个类的目的就是为了告诉系统，我们这个类中有哪些属性和行为</p></li><li><p>OC类声明中属性只能写在<font color="red">@interface</font> 和<font color="red">@end</font>之间的<font color="red">{}</font>中,</p><font color="red">注意</font>：编写oc类属性的时候，建议将所有属性的名称前面加上<font color="red"><strong> _ </strong></font></li></ul><pre class=" language-objective-c"><code class="language-objective-c">@interface Iphone :NSObject{    //注意：默认情况下，OC对象中属性是不能直接访问的    @public    //只要让类中的属性公开，以后就可以直接通过一个指向结构体的指针来操作对象中的属性    float _model;    int _cpu;    double _size;    int _color;}@end</code></pre><ul><li>看第1行，OC中使用关键字@interface来声明一个类，@interface后面紧跟着类名Iphone。</li><li>类名Student后面的冒号”:”表示继承，即第1行代码的意思是Iphone继承自NSObject。</li><li>第7~10行默认作用域是<font color="red">@protected</font>，即可以在IPhone类内部和子类中访问</li><li>类的成员变量必须写在大括号{ }里面</li></ul><h3 id="2、如何编写类的实现"><a href="#2、如何编写类的实现" class="headerlink" title="2、如何编写类的实现"></a>2、如何编写类的实现</h3><p> 以<font color="red">@implementation</font>开头，以<font color="red">@end</font>结尾，然后在class对应的地方写上声明时声明的类的名称，必须和声明的类名一模一样</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck6bqxk0j307802h3yg.jpg" alt=""></p><pre class=" language-objective-c"><code class="language-objective-c">@implementation Iphone//类的实现,类名必须跟声明时的类名一样- (int)_cpu {   // 直接返回成员变量_cpu     return _cpu;}@end</code></pre><h3 id="3、如何通过一个类来创建对象"><a href="#3、如何通过一个类来创建对象" class="headerlink" title="3、如何通过一个类来创建对象"></a>3、如何通过一个类来创建对象</h3><p>在oc中想要通过一个类来创建一个对象必须给类发送有个消息（好比c语言中调用方法一样）。而OC中是如何发送消息？</p><ul><li>在oc中只要想要发送消息就先写上 <font color="red">[类名称/对象名称 方法名称]</font>；</li><li>发送什么消息（调用什么方法）可以创建一个对象 <font color="red">new</font></li></ul><p>只要通过有个类调用类的<font color="red">new</font>方法，也就是给类发送一个叫做<font color="red">new</font>的消息后，系统内部就会做3件事情：</p><ul><li>为IPhone类创建出来的对象分配存储空间</li><li>初始化IPhone类创建出来的对象中的属性</li><li>返回IPhone类创建出来的对象对应的地址</li></ul><pre class=" language-objective-c"><code class="language-objective-c">    Iphone *p =  [Iphone new];    p->_color = 0;    p->_cpu = 64;    return 0;</code></pre><ul><li>通过一个IPhone类型的<font color="red">指针</font>接收了IPhone对象的<font color="red">地址</font></li><li>如果使用给一个指针保存了某一个对象的地址，那么我们就称这个指针位之为某个类型的对应的对象</li><li>利用IPhone类型的指针保存了IPhone对象的地址，那么我们就称IPhone类型的指针p之为IPhone的对象</li></ul><font color="red"><strong> OC中的类其实本质就是一个结构体，所以p这个指针其实指向了一个结构体 </strong></font>]]></content>
      
      
      <categories>
          
          <category> Objective-C学习整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桂林电子科技大学 </tag>
            
            <tag> mstar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体</title>
      <link href="/Objective-C%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/struct/"/>
      <url>/Objective-C%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/struct/</url>
      
        <content type="html"><![CDATA[<p><center>本文源出于—<a href="http://www.cnblogs.com/mjios/archive/2013/03/24/2977910.html" target="_blank" rel="noopener"><strong>小码哥</strong></a></center></p><p><hr></p><h2 id="一、什么是结构体"><a href="#一、什么是结构体" class="headerlink" title="一、什么是结构体"></a>一、什么是结构体</h2><ul><li>当一个整体由多个数据构成时，我们可以用数组来表示这个整体，但是数组有个特点：内部的每一个元素都必须是相同类型的数据。</li><li>在实际应用中，我们通常需要由不同类型的数据来构成一个整体，比如学生这个整体可以由姓名、年龄、身高等数据构成，这些数据都具有不同的类型，姓名可以是字符串类型，年龄可以是整型，身高可以是浮点型。</li><li>为此，C语言专门提供了一种构造类型来解决上述问题，这就是结构体，它允许内部的元素是不同类型的。</li></ul><h2 id="二、结构体的定义"><a href="#二、结构体的定义" class="headerlink" title="二、结构体的定义"></a>二、结构体的定义</h2><h3 id="1-定义形式"><a href="#1-定义形式" class="headerlink" title="1.定义形式"></a>1.定义形式</h3><p> 结构体内部的元素，也就是组成成分，我们一般称为”成员”。</p><p>结构体的一般定义形式为：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span>　结构体名<span class="token punctuation">{</span>    类型名<span class="token number">1</span>　成员名<span class="token number">1</span><span class="token punctuation">;</span>    类型名<span class="token number">2</span>　成员名<span class="token number">2</span><span class="token punctuation">;</span>    ……    类型名n　成员名n<span class="token punctuation">;</span>　　　<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><font color="blue">struct</font>是关键字，是结构体类型的标志。</p><h3 id="2-举例"><a href="#2-举例" class="headerlink" title="2.举例"></a>2.举例</h3><p>比如，我们定义一个学生</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> Student <span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 姓名</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 年龄</span>    <span class="token keyword">float</span> height<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 身高</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>上面定义了一个叫做Student的结构体，共有name、age、height3个成员。呵呵，看到这里是否有点面向对象的味道呢，其实这跟面向对象完全是两码事，只能说感觉有点像。</p><h2 id="三、结构体变量的定义"><a href="#三、结构体变量的定义" class="headerlink" title="三、结构体变量的定义"></a>三、结构体变量的定义</h2><p>前面只是定义了名字为Student的结构体类型，并非定义了一个结构体变量，就像int一样，只是一种类型。</p><p>接下来定义一个结构体变量，方式有好多种。</p><h3 id="1-先定义结构体类型，再定义变量"><a href="#1-先定义结构体类型，再定义变量" class="headerlink" title="1.先定义结构体类型，再定义变量"></a>1.先定义结构体类型，再定义变量</h3><pre class=" language-c"><code class="language-c"> <span class="token keyword">struct</span> Student <span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Student stu<span class="token punctuation">;</span></code></pre><p>第6行定义了一个结构体变量，变量名为stu。struct和Student是连着使用的。</p><h3 id="2-定义结构体类型的同时定义变量"><a href="#2-定义结构体类型的同时定义变量" class="headerlink" title="2.定义结构体类型的同时定义变量"></a>2.定义结构体类型的同时定义变量</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> Student <span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span> stu<span class="token punctuation">;</span></code></pre><p>结构体变量名为stu</p><h3 id="3-直接定义结构体类型变量，省略类型名"><a href="#3-直接定义结构体类型变量，省略类型名" class="headerlink" title="3.直接定义结构体类型变量，省略类型名"></a>3.直接定义结构体类型变量，省略类型名</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span> stu<span class="token punctuation">;</span></code></pre><p>结构体变量名为stu</p><h2 id="四、结构体的注意点"><a href="#四、结构体的注意点" class="headerlink" title="四、结构体的注意点"></a>四、结构体的注意点</h2><h3 id="1-不允许对结构体本身递归定义"><a href="#1-不允许对结构体本身递归定义" class="headerlink" title="1.不允许对结构体本身递归定义"></a>1.不允许对结构体本身递归定义</h3><p>如下做法是<font color="red">错误</font>的，注意第3行</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> Student <span class="token punctuation">{</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">struct</span> Student stu<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h3 id="2-结构体内可以包含别的结构体"><a href="#2-结构体内可以包含别的结构体" class="headerlink" title="2.结构体内可以包含别的结构体"></a>2.结构体内可以包含别的结构体</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> Date <span class="token punctuation">{</span>      <span class="token keyword">int</span> year<span class="token punctuation">;</span>      <span class="token keyword">int</span> month<span class="token punctuation">;</span>      <span class="token keyword">int</span> day<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Student <span class="token punctuation">{</span>     <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>     <span class="token keyword">struct</span> Date birthday<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>注意第9行</p><h3 id="3-定义结构体类型"><a href="#3-定义结构体类型" class="headerlink" title=" 3.定义结构体类型 "></a><strong> 3.定义结构体类型 </strong></h3><p>定义结构体类型只是说明了该类型的组成情况，并没有给它分配存储空间，就像系统不为int类型本身分配空间一样。只有当定义属于结构体类型的变量时，系统才会分配存储空间给该变量 </p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> Student <span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Student stu<span class="token punctuation">;</span></code></pre><p>第1~4行并没有分配存储空间，当执行到第6行时，系统才会分配存储空间给stu变量。</p><h3 id="4-结构体变量占用的内存空间是其成员所占内存之和，而且各成员在内存中按定义的顺序依次排列"><a href="#4-结构体变量占用的内存空间是其成员所占内存之和，而且各成员在内存中按定义的顺序依次排列" class="headerlink" title=" 4.结构体变量占用的内存空间是其成员所占内存之和，而且各成员在内存中按定义的顺序依次排列 "></a><strong> 4.结构体变量占用的内存空间是其成员所占内存之和，而且各成员在内存中按定义的顺序依次排列 </strong></h3><p>比如下面的Student结构体：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> Student <span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 姓名</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 年龄</span>    <span class="token keyword">float</span> height<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 身高</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>在16位编译器环境下，一个Student变量共占用内存：2 + 2 + 4 = 8字节。</p><h2 id="五、结构体的初始化"><a href="#五、结构体的初始化" class="headerlink" title="五、结构体的初始化"></a>五、结构体的初始化</h2><p>将各成员的初值，按顺序地放在一对大括号{}中，并用逗号分隔，一一对应赋值。</p><p>比如初始化Student结构体变量stu</p><pre class=" language-c"><code class="language-c"> <span class="token keyword">struct</span> Student <span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Student stu <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"MJ"</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>只能在定义变量的同时进行初始化赋值，初始化赋值和变量的定义不能分开，下面的做法是<font color="red">错误</font>的：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> Student stu<span class="token punctuation">;</span>stu <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"MJ"</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="六、结构体的使用"><a href="#六、结构体的使用" class="headerlink" title="六、结构体的使用"></a>六、结构体的使用</h2><h3 id="1-一般对结构体变量的操作是以成员为单位进行的，引用的一般形式为：结构体变量名-成员名"><a href="#1-一般对结构体变量的操作是以成员为单位进行的，引用的一般形式为：结构体变量名-成员名" class="headerlink" title=" 1.一般对结构体变量的操作是以成员为单位进行的，引用的一般形式为：结构体变量名.成员名 "></a><strong> 1.一般对结构体变量的操作是以成员为单位进行的，引用的一般形式为：结构体变量名.成员名 </strong></h3><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> Student <span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">struct</span> Student stu<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 访问stu的age成员</span>stu<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span></code></pre><p>第9行对结构体的age成员进行了赋值。”.”称为成员运算符，它在所有运算符中优先级最高</p><h3 id="2-如果某个成员也是结构体变量，可以连续使用成员运算符”-”访问最低一级成员"><a href="#2-如果某个成员也是结构体变量，可以连续使用成员运算符”-”访问最低一级成员" class="headerlink" title=" 2.如果某个成员也是结构体变量，可以连续使用成员运算符”.”访问最低一级成员 "></a><strong> 2.如果某个成员也是结构体变量，可以连续使用成员运算符”.”访问最低一级成员 </strong></h3><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> Date <span class="token punctuation">{</span>        <span class="token keyword">int</span> year<span class="token punctuation">;</span>        <span class="token keyword">int</span> month<span class="token punctuation">;</span>        <span class="token keyword">int</span> day<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Student <span class="token punctuation">{</span>        <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>        <span class="token keyword">struct</span> Date birthday<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Student stu<span class="token punctuation">;</span>stu<span class="token punctuation">.</span>birthday<span class="token punctuation">.</span>year <span class="token operator">=</span> <span class="token number">1986</span><span class="token punctuation">;</span>stu<span class="token punctuation">.</span>birthday<span class="token punctuation">.</span>month <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>stu<span class="token punctuation">.</span>birthday<span class="token punctuation">.</span>day <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre><p>注意第14行以后的代码</p><h3 id="3-相同类型的结构体变量之间可以进行整体赋值"><a href="#3-相同类型的结构体变量之间可以进行整体赋值" class="headerlink" title=" 3.相同类型的结构体变量之间可以进行整体赋值 "></a><strong> 3.相同类型的结构体变量之间可以进行整体赋值 </strong></h3><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> Student <span class="token punctuation">{</span>     <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>     <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">struct</span> Student stu1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"MJ"</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将stu1直接赋值给stu2</span> <span class="token keyword">struct</span> Student stu2 <span class="token operator">=</span> stu1<span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"age is %d"</span><span class="token punctuation">,</span> stu2<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>注意第9行。输出结果为：#### age is 27 ####</p><h2 id="七、结构体数组"><a href="#七、结构体数组" class="headerlink" title="七、结构体数组"></a>七、结构体数组</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>跟结构体变量一样，结构体数组也有3种定义方式</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> Student <span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> Student stu<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义1</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> Student <span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span> stu<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义2</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span> stu<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义3</span></code></pre><p>上面3种方式，都是定义了一个变量名为stu的结构体数组，数组元素个数是5</p><h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span> stu<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token string">"MJ"</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"JJ"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>也可以用数组下标访问每一个结构体元素，跟普通数组的用法是一样的</p><h2 id="八、结构体作为函数参数"><a href="#八、结构体作为函数参数" class="headerlink" title="八、结构体作为函数参数"></a>八、结构体作为函数参数</h2><p>将结构体变量作为函数参数进行传递时，其实传递的是全部成员的值，也就是将实参中成员的值一一赋值给对应的形参成员。因此，形参的改变不会影响到实参。</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span> <span class="token comment" spellcheck="true">// 定义一个结构体</span> <span class="token keyword">struct</span> Student <span class="token punctuation">{</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Student stu<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"修改前的形参：%d \n"</span><span class="token punctuation">,</span> stu<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 修改实参中的age</span>     stu<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"修改后的形参：%d \n"</span><span class="token punctuation">,</span> stu<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">struct</span> Student stu <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">30</span><span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"修改前的实参：%d \n"</span><span class="token punctuation">,</span> stu<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用test函数</span>     <span class="token function">test</span><span class="token punctuation">(</span>stu<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"修改后的实参：%d \n"</span><span class="token punctuation">,</span> stu<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><ul><li><p>首先在第4行定义了一个结构体类型Student</p></li><li><p>在第18行定义了一个结构体变量stu，并在第22行将其作为实参传入到test函数</p></li></ul><p>输出结果为：<img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ckm301j2j3050030aa3.jpg" alt=""><br>形参是改变了，但是实参一直没有变过</p><h2 id="九、指向结构体的指针"><a href="#九、指向结构体的指针" class="headerlink" title="九、指向结构体的指针"></a>九、指向结构体的指针</h2><blockquote><p>每个结构体变量都有自己的存储空间和地址，因此指针也可以指向结构体变量</p></blockquote><blockquote><p>结构体指针变量的定义形式：struct 结构体名称 *指针变量名</p></blockquote><blockquote><p>有了指向结构体的指针，那么就有3种访问结构体成员的方式</p></blockquote><ul><li>结构体变量名.成员名</li><li>(*指针变量名).成员名</li><li>指针变量名-&gt;成员名</li></ul><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 定义一个结构体类型</span>     <span class="token keyword">struct</span> Student <span class="token punctuation">{</span>         <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>         <span class="token keyword">int</span> age<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 定义一个结构体变量</span>     <span class="token keyword">struct</span> Student stu <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"MJ"</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 定义一个指向结构体的指针变量</span>     <span class="token keyword">struct</span> Student <span class="token operator">*</span>p<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 指向结构体变量stu</span>     p <span class="token operator">=</span> <span class="token operator">&amp;</span>stu<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/*      这时候可以用3种方式访问结构体的成员     */</span>    <span class="token comment" spellcheck="true">// 方式1：结构体变量名.成员名</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"name=%s, age = %d \n"</span><span class="token punctuation">,</span> stu<span class="token punctuation">.</span>name<span class="token punctuation">,</span> stu<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 方式2：(*指针变量名).成员名</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"name=%s, age = %d \n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 方式3：指针变量名->成员名</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"name=%s, age = %d \n"</span><span class="token punctuation">,</span> p<span class="token operator">-></span>name<span class="token punctuation">,</span> p<span class="token operator">-></span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>输出结果： <img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ckmbmkkwj305w027wec.jpg" alt=""></p><hr><p><strong><em>本文仅作为个人的随身读书笔记收集，没有用于任何商业盈利范畴。如若有侵犯源作者的著作权，请联系本人（立马撤文）<a href="mailto:mstarzheng@foxmail.com" target="_blank" rel="noopener">mstarzheng@foxmail.com</a></em></strong></p>]]></content>
      
      
      <categories>
          
          <category> Objective-C学习整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桂林电子科技大学 </tag>
            
            <tag> mstar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac折腾手记（三）--- 百度云盘限制破解</title>
      <link href="/mac%E7%AC%94%E8%AE%B0/baiduyun/"/>
      <url>/mac%E7%AC%94%E8%AE%B0/baiduyun/</url>
      
        <content type="html"><![CDATA[<h2 id="Mac-百度云加速下载，突破限速，大文件无压力（小白使用无压力）"><a href="#Mac-百度云加速下载，突破限速，大文件无压力（小白使用无压力）" class="headerlink" title="Mac 百度云加速下载，突破限速，大文件无压力（小白使用无压力）"></a>Mac 百度云加速下载，突破限速，大文件无压力（小白使用无压力）</h2><p><hr><br>相信使用mac的同学们在使用百度云下载本站软件时肯定碰到过很多问题吧，尤其是大文件。最主要的是Mac端的同步盘太难用了，而且好像已经被官方抛弃了一样，很久都没有更新了。直接浏览器下载吧～限速不说，碰到大文件了还会断开，真是让人又气有无奈。</p><p>话不多说，有了这个新方法，虽然可以完全抛弃windows版的百度云了，但是要是照顾一下Windows用户的。这里分享一个windows上的百度云管家<a href="https://pan.baidu.com/s/1hsl4fMO" target="_blank" rel="noopener"> <font color="red">提速破解版</font> </a> 密码: 2nru。</p><p>接下来直奔Mac的主题。傻瓜安装法（更适合小白同学）</p><blockquote><p>1、先下载<a href="https://github.com/yangshun1029/aria2gui/releases" target="_blank" rel="noopener">Aria2GUI dmg</a>，解压并安装。</p></blockquote><ul><li><font color="red">下载好后安装：每次下载东西的时候都需要打开这个Aria2GUI客户端</font></li></ul><blockquote><p>2、<a href="https://github.com/acgotaku/BaiduExporter/releases" target="_blank" rel="noopener">网盘助手</a></p></blockquote><ul><li><font color="red">插件目前只有chrome版本在一直维护，所以，只适用于chrome浏览器，按照以下方法，安装完了以后，在百度云的下载界面会多出来一个 “导出下载”的按钮，点击这个里面的”ARIA2 RPC”，下载任务会自动在Aria2GUI客户端中开始</font></li></ul><p>目前百度云插件已停止打包，使用最新版本方法如下：</p><p>下载<a href="https://github.com/acgotaku/BaiduExporter" target="_blank" rel="noopener">百度云插件源代码</a> 并解压，如图</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2bteyuymsj31kk0hujvj.jpg" alt=""></p><p>直接将下载好的文件夹中的<font color="red"> chrome.crx </font>文件拖动到浏览器的 <font color="red">扩展程序</font>界面进行安装。</p><p><font color="red">安装完毕后请参考</font>：</p><ul><li><a href="https://mstarzheng.github.io/2017/04/02/study-mac/" target="_blank" rel="noopener">mac折腾手记（二）— 将非官方扩展程序加入chrome的白名单</a> <font color="red">解决扩展程序失效停用的问题</font><br><br><br>以上步骤都顺利完成，会在你的网页版的百度云盘中多出一个<font color="red">导出下载</font>，如图所示：</li></ul><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2bteydaaej316e0cgwgh.jpg" alt=""></p><p>接下就开始尽情的使用你的装X神器吧！！！</p>]]></content>
      
      
      <categories>
          
          <category> mac笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桂林电子科技大学 </tag>
            
            <tag> mstar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac折腾手记（二）</title>
      <link href="/mac%E7%AC%94%E8%AE%B0/study-mac/"/>
      <url>/mac%E7%AC%94%E8%AE%B0/study-mac/</url>
      
        <content type="html"><![CDATA[<h2 id="将非官方扩展程序加入chrome的白名单"><a href="#将非官方扩展程序加入chrome的白名单" class="headerlink" title="将非官方扩展程序加入chrome的白名单"></a>将非官方扩展程序加入chrome的白名单</h2><hr><blockquote><p>在chrome中正常使用并非来自 Chrome 网上应用店的扩展,会出现下面的情况：</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ckna8t24j31560a60uu.jpg" alt=""></p><p>小编在网上也找到了一些 <a href="https://hencolle.com/2016/10/16/baidu_exporter/" target="_blank" rel="noopener">英文文档</a>来解决这类问题。</p><blockquote><font color="red">注意：该方法只适用于 通过 crx 文件安装的扩展（将crx文件拖入chrome扩展程序界面）</font></blockquote><p>而还有一些类似小编一样英文不好的同学，该怎么办呢？没事你们的福利来了，跟着我一步步来走吧。。。</p><p>1、首先下载有个描述文件：<a href="https://gist.github.com/Explorare/be3dd598289252698cd37bca04abd0fe#file-com-google-chrome-mobileconfig" target="_blank" rel="noopener">Github地址</a><br>下载不下来的，再提供一个<a href="https://pan.baidu.com/s/1eRPT11g" target="_blank" rel="noopener">网盘地址</a> 密码：dvfx</p><p>2、打开 chrome的 <font color="red">扩展程序 </font>界面，复制扩展的ID。<br><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cknqi78hj317a0aemzc.jpg" alt=""></p><p>3、用文本编辑器打开下载好的com.google.Chrome.mobileconfig找到如图所示位置：</p><pre class=" language-HTML"><code class="language-HTML"><?xml version="1.0" encoding="UTF-8"?><!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"><plist version="1.0"><dict>    <key>PayloadContent</key>    <array>        <dict>            <key>PayloadContent</key>            <dict>                <key>com.google.Chrome</key>                <dict>                    <key>Forced</key>                    <array>                        <dict>                            <key>mcx_preference_settings</key>                            <dict>                                <key>ExtensionInstallWhitelist</key>                                <array>                                    <string>value01</string>                                    <string>value02</string>                                    <string>value03</string>                                </array>                            </dict>                        </dict>                    </array>                </dict>            </dict>            <key>PayloadEnabled</key>            <true/>            <key>PayloadIdentifier</key>            <string>MCXToProfile.7e2bec75-299e-44ff-b405-628007abffff.alacarte.customsettings.bdac4880-d25f-4cdd-8472-05473f005e7e</string>            <key>PayloadType</key>            <string>com.apple.ManagedClient.preferences</string>            <key>PayloadUUID</key>            <string>bdac4880-d25f-4cdd-8472-05473f005e7e</string>            <key>PayloadVersion</key>            <integer>1</integer>        </dict>    </array>    <key>PayloadDescription</key>    <string>Included custom settings:com.google.Chrome</string>    <key>PayloadDisplayName</key>    <string>MCXToProfile: com.google.Chrome</string>    <key>PayloadIdentifier</key>    <string>com.google.Chrome</string>    <key>PayloadOrganization</key>    <string></string>    <key>PayloadRemovalDisallowed</key>    <true/>    <key>PayloadScope</key>    <string>System</string>    <key>PayloadType</key>    <string>Configuration</string>    <key>PayloadUUID</key>    <string>7e2bec75-299e-44ff-b405-628007abffff</string>    <key>PayloadVersion</key>    <integer>1</integer></dict></plist></code></pre><p>这里的 19-21行 <string></string> 中分别对应单个扩展的ID，如果只需要一个的话，可以吧多余的两个删掉，将其中的一个标签中的值替换为第二步复制过来的 ID。编辑完后保存。如图：</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ckmq6j0yj314y0qk7mv.jpg" alt=""></p><p>4、双击打开第三步编辑好的描述文件，按照弹出的提示点击 继续-安装（输入电脑密码），安装结束后重启浏览器，就可以勾选这个扩展了，并且以后重启浏览器也不会有停用的提示了！</p>]]></content>
      
      
      <categories>
          
          <category> mac笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桂林电子科技大学 </tag>
            
            <tag> mstar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac折腾手记（一）---软件安装</title>
      <link href="/mac%E7%AC%94%E8%AE%B0/mac-softer/"/>
      <url>/mac%E7%AC%94%E8%AE%B0/mac-softer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题记：小编之前也是忠实的Windows的使用者，但是自从上手了第一个Mac后，瞬间就爱上了这台电脑，有一种上手恨晚的感觉。但是加上小编之前习惯使用Windows电脑，所以刚上手Mac甚是不习惯，比如好多安装软件都是收费的等。但是试用几天后，感觉甚是爽哉！！！下面呢，小编就带领着大家绕过装逼的这些坑。。。。。。</p></blockquote><p><hr><br>上来先放两个大招，对于我们在天朝一直使用免费软件的童鞋们，简直是福利呀！！！</p><ul><li><a href="http://xclient.info/" target="_blank" rel="noopener">国内网址</a> 可以满足大部分人的需求</li></ul><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck4h2qhyj31we0dk7bv.jpg" alt=""></p><ul><li><a href="http://mac-torrent-download.net/" target="_blank" rel="noopener">国外网址</a> 这两简直是宝藏呀（可能需要翻墙，你懂得）</li></ul><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck4qyz0fj31qy0g245l.jpg" alt=""></p><p>但牛逼的Mac系统总会让你遇到各种问题。</p><blockquote><p>有些用户下载了一些程序之后，却发现无法在MAC中安装，安装时会弹出下图所示警告框：“打不开 xxx，因为它来自身份不明的开发者”。那么该如何解决这个问题呢？</p></blockquote><p>在MAC下安装一些软件时提示”来自身份不明开发者”，其实这是MAC新系统启用了新的安全机制。<br>默认只信任 Mac App Store 下载的软件和拥有开发者 ID 签名的应用程序。<br>换句话说就是 MAC 系统默认只能安装靠谱渠道（有苹果审核的 Mac App Store）下载的软件或被认可的人开发的软件。</p><p>这当然是为了用户不会稀里糊涂安装流氓软件中招，但没有开发者签名的 “老实软件” 也受影响了，安装就会弹出下图所示警告框：“打不开 xxx，因为它来自身份不明的开发者”。</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck4yu5k1j313o0hq4bp.jpg" alt=""></p><p>出现这个问题的解决方法有2种：</p><ul><li>1、最简单的方式：按住Control后，再次点击软件图标，即可。</li><li>2、修改系统配置：系统偏好设置… -&gt; 安全性与隐私。</li></ul><p>系统偏好设置</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck55r39qj311a0x8k0z.jpg" alt=""></p><p>安全性与隐私</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck5bzs1jj31160u843m.jpg" alt=""></p><p>认证</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck5ie3pnj30ow0ck0uo.jpg" alt=""></p><p>修改为任何来源</p><font color="red"> ### 高能预警！！！！！！！！(专门为不仔细看文章的准备的。。。。。。。) ### </font><blockquote><p>如果没有这个选项的话（macOS Sierra 10.12）,打开<font color="red">终端</font>，执行<font color="red">sudo spctl –master-disable</font>即可</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck5ptahzj313o0uoaqg.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> mac笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桂林电子科技大学 </tag>
            
            <tag> mstar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>执行上下文详细图解</title>
      <link href="/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/context/"/>
      <url>/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/context/</url>
      
        <content type="html"><![CDATA[<p><center>本文源出于—简书<a href="http://www.jianshu.com/p/a6d37c77e8db" target="_blank" rel="noopener"><strong>波同学</strong></a></center></p><hr><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjtju136j30ws08wwej.jpg" alt=""></p><p>我们在JS学习初期或者面试的时候常常会遇到考核变量提升的思考题。比如先来一个简单一点的。</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 这里会打印出什么？</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></code></pre><p>暂时先不管这个例子，我们先引入一个JavaScript中最基础，但同时也是最重要的一个概念<strong> 执行上下文（Execution Context）</strong>。</p><p>每次当控制器转到可执行代码的时候，就会进入一个执行上下文。执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。JavaScript中的运行环境大概包括三种情况。</p><ul><li>全局环境：JavaScript代码运行起来会首先进入该环境</li><li>函数环境：当函数被调用执行时，会进入当前函数中执行代码</li><li>eval</li></ul><p>因此在一个JavaScript程序中，必定会产生多个执行上下文，在我的上一篇文章中也有提到，JavaScript引擎会以堆栈的方式来处理它们，这个堆栈，我们称其为函数调用栈(call stack)。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。</p><p>当代码在执行过程中，遇到以上三种情况，都会生成一个执行上下文，放入栈中，而处于栈顶的上下文执行完毕之后，就会自动出栈。为了更加清晰的理解这个过程，根据下面的例子，结合图示给大家展示。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> color <span class="token operator">=</span> <span class="token string">'blue'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">changeColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> anotherColor <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">swapColors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> tempColor <span class="token operator">=</span> anotherColor<span class="token punctuation">;</span>        anotherColor <span class="token operator">=</span> color<span class="token punctuation">;</span>        color <span class="token operator">=</span> tempColor<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">swapColors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">changeColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>我们用ECStack来表示处理执行上下文组的堆栈。我们很容易知道，第一步，首先是全局上下文入栈。</p><ul><li>第一步：全局上下文入栈:</li></ul><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjtu94z6j30go08cmwz.jpg" alt=""></p><p>全局上下文入栈之后，其中的可执行代码开始执行，直到遇到了changeColor()，这一句激活函数changeColor创建它自己的执行上下文，因此第二步就是changeColor的执行上下文入栈。</p><ul><li>第二步：changeColor的执行上下文入栈:</li></ul><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cju38zrrj30go08ca9w.jpg" alt=""></p><p>changeColor的上下文入栈之后，控制器开始执行其中的可执行代码，遇到swapColors()之后又激活了一个执行上下文。因此第三步是swapColors的执行上下文入栈。</p><ul><li>第三步：swapColors的执行上下文入栈:</li></ul><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjudk4v0j30go08cq2s.jpg" alt=""></p><p>在swapColors的可执行代码中，再没有遇到其他能生成执行上下文的情况，因此这段代码顺利执行完毕，swapColors的上下文从栈中弹出。</p><ul><li>第四步：swapColors的执行上下文出栈:</li></ul><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjulzhufj30go08ca9w.jpg" alt=""></p><p>swapColors的执行上下文弹出之后，继续执行changeColor的可执行代码，也没有再遇到其他执行上下文，顺利执行完毕之后弹出。这样，ECStack中就只身下全局上下文了。</p><ul><li>第五步：changeColor的执行上下文出栈</li></ul><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjuscacyj30go08cmwz.jpg" alt=""></p><p>全局上下文在浏览器窗口关闭后出栈。</p><blockquote><p>注意：函数中，遇到return能直接终止可执行代码的执行，因此会直接将当前上下文弹出栈。</p><ul><li>上例演变过程:</li></ul></blockquote><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjv0cmbmj30ws08wwej.jpg" alt=""></p><p>详细了解了这个过程之后，我们就可以对执行上下文总结一些结论了。</p><ul><li>单线程</li><li>同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待</li><li>全局上下文只有唯一的一个，它在浏览器关闭时出栈</li><li>函数的执行上下文的个数没有限制</li><li>每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此。</li></ul><p>为了巩固一下执行上下文的理解，我们再来绘制一个例子的演变过程，这是一个简单的闭包例子。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> n<span class="token operator">=</span><span class="token number">999</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> f2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> result<span class="token operator">=</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 999</span></code></pre><p>因为f1中的函数f2在f1的可执行代码中，并没有被调用执行，因此执行f1时，f2不会创建新的上下文，而直到result执行时，才创建了一个新的。具体演变过程如下。</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjvaqzcaj30ws09qjrd.jpg" alt=""></p><p><strong><em>本文仅作为个人的随身读书笔记收集，没有用于任何商业盈利范畴。如若有侵犯源作者的著作权，请联系本人（立马撤文）<a href="mailto:mstarzheng@foxmail.com" target="_blank" rel="noopener">mstarzheng@foxmail.com</a></em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端面试总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桂林电子科技大学 </tag>
            
            <tag> mstar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全方位解读this</title>
      <link href="/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/this/"/>
      <url>/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/this/</url>
      
        <content type="html"><![CDATA[<p><center>本文源出于—简书<a href="http://www.jianshu.com/p/d647aa6d1ae6" target="_blank" rel="noopener"><strong>波同学</strong></a></center></p><p><hr><br>回顾一下执行上下文声明周期<br><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cko3ssluj30rs0823yj.jpg" alt=""></p><p>在执行上下文的创建阶段，会分别生成变量对象，建立作用域链，确定this指向。其中变量对象与作用域链我们都已经仔细总结过了，而这里的关键，就是确定this指向。</p><p>在这里，我们需要得出一个非常重要一定要牢记于心的结论，<strong> this的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的 </strong>。因此我们可以很容易就能理解到，一个函数中的this指向，可以是非常灵活的。比如下面的例子中，同一个函数由于调用方式的不同，this指向了不一样的对象。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">}</span><span class="token keyword">function</span> fn <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 10</span>fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 20</span></code></pre><p>除此之外，<strong> 在函数执行过程中，this一旦被确定，就不可更改了 </strong>。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">}</span><span class="token keyword">function</span> fn <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这句话试图修改this，运行后会报错</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><hr><h2 id="一、全局对象中的this"><a href="#一、全局对象中的this" class="headerlink" title="一、全局对象中的this"></a>一、全局对象中的this</h2><p>关于全局对象的this，我之前在总结变量对象的时候提到过，它是一个比较特殊的存在。全局环境中的this，指向它本身。因此，这也相对简单，没有那么多复杂的情况需要考虑。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 通过this绑定到全局对象</span><span class="token keyword">this</span><span class="token punctuation">.</span>a2 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 通过声明绑定到变量对象，但在全局环境中，变量对象就是它自身</span><span class="token keyword">var</span> a1 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 仅仅只有赋值操作，标识符会隐式绑定到全局对象</span>a3 <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出结果会全部符合预期</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a3<span class="token punctuation">)</span></code></pre><hr><h2 id="二、函数中的this"><a href="#二、函数中的this" class="headerlink" title="二、函数中的this"></a>二、函数中的this</h2><p>在总结函数中this指向之前，我想我们有必要通过一些奇怪的例子，来感受一下函数中this的捉摸不定。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// demo01</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// demo02</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// demo03</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>    c<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">+</span> <span class="token number">20</span><span class="token punctuation">,</span>    fn<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这几个例子需要读者老爷们花点时间稍微感受一下，如果你暂时没想明白怎么回事，也不用着急，我们一点一点来分析。</p><p>分析之前，我们先直接了当抛出结论。</p><p>在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。<strong> 如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined </strong>。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。</p><p>从结论中我们可以看出，想要准确确定this指向，找到函数的调用者以及区分他是否是独立调用就变得十分关键。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 为了能够准确判断，我们在函数内部使用严格模式，因为非严格模式会自动指向全局</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token string">'use strict'</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// fn是调用者，独立调用</span>window<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// fn是调用者，被window所拥有</span></code></pre><p>在上面的简单例子中，fn()作为独立调用者，按照定义的理解，它内部的this指向就为undefined。而window.fn()则因为fn被window所拥有，内部的this就指向了window对象。</p><p>那么掌握了这个规则，现在回过头去看看上面的三个例子，通过添加/去除严格模式，那么你就会发现，原来this已经变得不那么虚无缥缈，已经有迹可循了。</p><p>但是我们需要特别注意的是demo03。在demo03中，对象obj中的c属性使用this.a + 20来计算，而他的调用者obj.c并非是一个函数。因此他不适用于上面的规则，我们要对这种方式单独下一个结论。</p><p><strong> 当obj在全局声明时，无论obj.c在什么地方调用，这里的this都指向全局对象，而当obj在函数环境中声明时，这个this指向undefined，在非严格模式下，会自动转向全局对象 </strong>。可运行下面的例子查看区别。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token string">'use strict'</span><span class="token punctuation">;</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">function</span> foo <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>        a<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>        c<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">+</span> <span class="token number">20</span><span class="token punctuation">,</span>        fn<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> obj<span class="token punctuation">.</span>c<span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 运行会报错</span></code></pre><ul><li>实际开发中，并不推荐这样使用this；</li><li>上面多次提到的严格模式，需要大家认真对待，因为在实际开发中，现在基本已经全部采用严格模式了，而最新的ES6，也是默认支持严格模式。</li></ul><p>再来看一些容易理解错误的例子，加深一下对调用者与是否独立运行的理解。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>    getA<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span><span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 10</span><span class="token keyword">var</span> test <span class="token operator">=</span> foo<span class="token punctuation">.</span>getA<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 20</span></code></pre><p>foo.getA()中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而test()作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。</p><p>稍微修改一下代码，大家自行理解。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>    getA<span class="token punctuation">:</span> getA<span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span><span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 10</span></code></pre><p>灵机一动，再来一个。如下例子。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">active</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 真实调用者，为独立调用</span><span class="token punctuation">}</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>    getA<span class="token punctuation">:</span> foo<span class="token punctuation">}</span><span class="token function">active</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>getA<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><hr></p><h2 id="三、使用call，apply显示指定this"><a href="#三、使用call，apply显示指定this" class="headerlink" title="三、使用call，apply显示指定this"></a>三、使用call，apply显示指定this</h2><p>JavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有着两个方法。它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。</p><p>如下例子所示。fn并非属于对象obj的方法，但是通过call，我们将fn内部的this绑定为obj，因此就可以使用this.a访问obj的a属性了。这就是call/apply的用法。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">}</span>fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>而call与applay后面的参数，都是向将要执行的函数传递参数。其中call以一个一个的形式传递，apply以数组的形式传递。这是他们唯一的不同。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">+</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">}</span>fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 130</span>fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 50</span></code></pre><p>因为call/apply的存在，这让JavaScript变得十分灵活。因此就让call/apply拥有了很多有用处的场景。简单总结几点，也欢迎大家补充。</p><ul><li>将类数组对象转换为数组</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">exam</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 先看看函数的自带属性 arguments 什么是样子的</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用call/apply将arguments转换为数组, 返回结果为数组，arguments自身不会改变</span>    <span class="token keyword">var</span> arg <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">exam</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// result:</span><span class="token comment" spellcheck="true">// { '0': 2, '1': 8, '2': 9, '3': 10, '4': 3 }</span><span class="token comment" spellcheck="true">// [ 2, 8, 9, 10, 3 ]</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 也常常使用该方法将DOM中的nodelist转换为数组</span><span class="token comment" spellcheck="true">// [].slice.call( document.getElementsByTagName('li') );</span></code></pre><ul><li>根据自己的需要灵活修改this指向</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'joker'</span><span class="token punctuation">,</span>    showName<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'rose'</span><span class="token punctuation">}</span>foo<span class="token punctuation">.</span>showName<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>实现继承</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 定义父级的构造函数</span><span class="token keyword">var</span> Person <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age  <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>gender <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'man'</span><span class="token punctuation">,</span> <span class="token string">'woman'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 定义子类的构造函数</span><span class="token keyword">var</span> Student <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// use call</span>    Person<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>high <span class="token operator">=</span> high<span class="token punctuation">;</span><span class="token punctuation">}</span>Student<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'name:'</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">+</span><span class="token string">', age:'</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">+</span><span class="token string">', high:'</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>high<span class="token operator">+</span><span class="token string">', gender:'</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>gender<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">';'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">'xiaom'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token string">'150cm'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// result</span><span class="token comment" spellcheck="true">// ----------</span><span class="token comment" spellcheck="true">// name:xiaom, age:12, high:150cm, gender:man;</span></code></pre><p>简单给有面向对象基础的朋友解释一下。在Student的构造函数中，借助call方法，将父级的构造函数执行了一次，相当于将Person中的代码，在Sudent中复制了一份，其中的this指向为从Student中new出来的实例对象。call方法保证了this的指向正确，因此就相当于实现了基层。Student的构造函数等同于下。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> Student <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age  <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>gender <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'man'</span><span class="token punctuation">,</span> <span class="token string">'woman'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Person.call(this, name, age); 这一句话，相当于上面三句话，因此实现了继承</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>high <span class="token operator">=</span> high<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>在向其他执行上下文的传递中，确保this的指向保持不变</li></ul><p>如下面的例子中，我们期待的是getA被obj调用时，this指向obj，但是由于匿名函数的存在导致了this指向的丢失，在这个匿名函数中this指向了全局，因此我们需要想一些办法找回正确的this指向。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>    getA<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>obj<span class="token punctuation">.</span><span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>常规的解决办法很简单，就是使用一个变量，将this的引用保存起来。我们常常会用到这方法，但是我们也要借助上面讲到过的知识，来判断this是否在传递中被修改了，如果没有被修改，就没有必要这样使用了。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>    getA<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>a<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>另外就是借助闭包与apply方法，封装一个bind方法。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">bind</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>    getA<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>obj<span class="token punctuation">.</span><span class="token function">getA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>当然，也可以使用ES5中已经自带的bind方法。它与我上面封装的bind方法是一样的效果。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>    getA<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><h2 id="四、构造函数与原型方法上的this"><a href="#四、构造函数与原型方法上的this" class="headerlink" title="四、构造函数与原型方法上的this"></a>四、构造函数与原型方法上的this</h2><p>在封装对象的时候，我们几乎都会用到this，但是，只有少数人搞明白了在这个过程中的this指向，就算我们理解了原型，也不一定理解了this。所以这一部分，我认为将会为这篇文章最重要最核心的部分。理解了这里，将会对你学习JS面向对象产生巨大的帮助。</p><p>结合下面的例子，我在例子抛出几个问题大家思考一下。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里的this指向了谁?</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里的this又指向了谁？</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 上面的2个this，是同一个吗，他们是否指向了原型对象？</span><span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Nick'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>我们已经知道，this，是在函数调用过程中确定，因此，搞明白new的过程中到底发生了什么就变得十分重要。</p><p>通过new操作符调用构造函数，会经历以下4个阶段。</p><ul><li>创建一个新的对象；</li><li>将构造函数的this指向这个新对象；</li><li>指向构造函数的代码，为这个对象添加属性，方法等；</li><li>返回新对象。</li></ul><p>因此，当new操作符调用构造函数时，this其实指向的是这个新创建的对象，最后又将新的对象返回出来，被实例对象p1接收。因此，我们可以说，这个时候，构造函数的this，指向了新的实例对象，p1。</p><p>而原型方法上的this就好理解多了，根据上边对函数中this的定义，p1.getName()中的getName为调用者，他被p1所拥有，因此getName中的this，也是指向了p1。</p><hr><p><strong><em>本文仅作为个人的随身读书笔记收集，没有用于任何商业盈利范畴。如若有侵犯源作者的著作权，请联系本人（立马撤文）<a href="mailto:mstarzheng@foxmail.com" target="_blank" rel="noopener">mstarzheng@foxmail.com</a></em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端面试总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桂林电子科技大学 </tag>
            
            <tag> mstar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详细图解作用域链与闭包</title>
      <link href="/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/closure/"/>
      <url>/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/closure/</url>
      
        <content type="html"><![CDATA[<center>本文源出于—简书<a href="http://www.jianshu.com/p/21a16d44f150" target="_blank" rel="noopener"><strong>波同学</strong></a></center><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjrdksknj30yg0h7q4d.jpg" alt=""></p><p><hr></p><h2 id="一、作用域与作用域链"><a href="#一、作用域与作用域链" class="headerlink" title="一、作用域与作用域链"></a>一、作用域与作用域链</h2><p>在详细讲解作用域链之前，我默认你已经大概明白了JavaScript中的下面这些重要概念。这些概念将会非常有帮助。</p><ul><li>基础数据类型与引用数据类型</li><li>内存空间</li><li>垃圾回收机制</li><li>执行上下文</li><li>变量对象与活动对象</li></ul><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>在JavaScript中，我们可以将作用域定义为一套规则,这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。</p><blockquote><p>这里的标识符，指的是变量名或者函数名</p></blockquote><ul><li>JavaScript中只有全局作用域与函数作用域(因为eval我们平时开发中几乎不会用到它，这里不讨论)。</li><li>作用域与执行上下文是完全不同的两个概念。我知道很多人会混淆他们，但是一定要仔细区分。</li></ul><blockquote><p>JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjrmtl3nj30yg0czmy5.jpg" alt=""></p><h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>之前我们分析的执行上下文的生命周期，如下图。</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjruniujj30rs082gln.jpg" alt=""></p><p>我们发现，作用域链是在执行上下文的创建阶段生成的。这个就奇怪了。上面我们刚刚说作用域在编译阶段确定规则，可是为什么作用域链却在执行阶段确定呢？</p><p>之所以有这个疑问，是因为大家对作用域和作用域链有一个误解。我们上面说了，作用域是一套规则，那么作用域链是什么呢？是这套规则的具体实现。所以这就是作用域与作用域链的关系，相信大家都应该明白了吧。</p><p>我们知道函数在调用激活时，会开始创建对应的执行上下文，在执行上下文生成的过程中，变量对象，作用域链，以及this的值会分别被确定。之前们详细说明了变量对象，而这里，我们将详细说明作用域链。</p><p><strong> 作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。 </strong></p><p>为了帮助大家理解作用域链，我我们先结合一个例子，以及相应的图示来说明。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">innerTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">innerTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在上面的例子中，全局，函数test，函数innerTest的执行上下文先后创建。我们设定他们的变量对象分别为VO(global)，VO(test), VO(innerTest)。而innerTest的作用域链，则同时包含了这三个变量对象，所以innerTest的执行上下文可如下表示。</p><pre class=" language-javascript"><code class="language-javascript">innerTestEC <span class="token operator">=</span> <span class="token punctuation">{</span>    VO<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 变量对象</span>    scopeChain<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token function">VO</span><span class="token punctuation">(</span>innerTest<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">VO</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">VO</span><span class="token punctuation">(</span>global<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 作用域链</span>    <span class="token keyword">this</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>是的，你没有看错，我们可以直接用一个数组来表示作用域链，数组的第一项scopeChain[0]为作用域链的最前端，而数组的最后一项，为作用域链的最末端，所有的最末端都为全局变量对象。</p><p>很多人会误解为当前作用域与上层作用域为包含关系，但其实并不是。以最前端为起点，最末端为终点的单方向通道我认为是更加贴切的形容。如图。</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjs2l1o4j30yg0frjsh.jpg" alt=""></p><blockquote><p>注意，因为变量对象在执行上下文进入执行阶段时，就变成了活动对象，这一点在上一篇文章中已经讲过，因此图中使用了AO来表示。Active Object</p></blockquote><p>是的，作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符，这样就可以访问到上一层作用域中的变量了。</p><hr><h2 id="二、闭包"><a href="#二、闭包" class="headerlink" title="二、闭包"></a>二、闭包</h2><p>对于那些有一点 JavaScript 使用经验但从未真正理解闭包概念的人来说，理解闭包可以看作是某种意义上的重生，突破闭包的瓶颈可以使你功力大增。</p><ul><li>闭包与作用域链息息相关；</li><li>闭包是在函数执行过程中被确认。</li></ul><p>先直截了当的抛出闭包的定义：<font color="red">当函数可以记住并访问所在的作用域(全局作用域除外)时，就产生了闭包，即使函数是在当前作用域之外执行。</font></p><blockquote><p>简单来说，假设函数A在函数B的内部进行定义了，并且当函数A在执行时，访问了函数B内部的变量对象，那么B就是一个闭包</p></blockquote><p>JavaScript的垃圾回收机制。JavaScript拥有自动的垃圾回收机制，关于垃圾回收机制，有一个重要的行为，那就是，当一个值，在内存中失去引用时，垃圾回收机制会根据特殊的算法找到它，并将其回收，释放内存。</p><p>而我们知道，函数的执行上下文，在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。</p><p>先来一个简单的例子。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">innnerFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    fn <span class="token operator">=</span> innnerFoo<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将 innnerFoo的引用，赋值给全局变量中的fn</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 此处的保留的innerFoo的引用</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span></code></pre><p>在上面的例子中，foo()执行完毕之后，按照常理，其执行环境生命周期会结束，所占内存被垃圾收集器释放。但是通过fn = innerFoo，函数innerFoo的引用被保留了下来，复制给了全局变量fn。这个行为，导致了foo的变量对象，也被保留了下来。于是，函数fn在函数bar内部执行时，依然可以访问这个被保留下来的变量对象。所以此刻仍然能够访问到变量a的值。</p><p>这样，我们就可以称foo为闭包。</p><p>下图展示了闭包foo的作用域链。</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjsg4yavj30yg0h7q4d.jpg" alt=""></p><p>我们可以在chrome浏览器的开发者工具中查看这段代码运行时产生的函数调用栈与作用域链的生成情况。如下图。</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjsml7juj30yg0h643k.jpg" alt=""></p><p>在上面的图中，红色箭头所指的正是闭包。其中Call Stack为当前的函数调用栈，Scope为当前正在被执行的函数的作用域链，Local为当前的局部变量。</p><p><font color="red">所以，通过闭包，我们可以在其他的执行上下文中，访问到函数的内部变量。</font>比如在上面的例子中，我们在函数bar的执行环境中访问到了函数foo的a变量。个人认为，从应用层面，这是闭包最重要的特性。利用这个特性，我们可以实现很多有意思的东西。</p><p>不过读者老爷们需要注意的是，虽然例子中的闭包被保存在了全局变量中，但是闭包的作用域链并不会发生任何改变。在闭包中，能访问到的变量，仍然是作用域链上能够查询到的变量。</p><p>对上面的例子稍作修改，如果我们在函数bar中声明一个变量c，并在闭包fn中试图访问该变量，运行结果会抛出错误。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">innnerFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在这里，试图访问函数bar中的c变量，会抛出错误</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    fn <span class="token operator">=</span> innnerFoo<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将 innnerFoo的引用，赋值给全局变量中的fn</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 此处的保留的innerFoo的引用</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="闭包的应用场景"><a href="#闭包的应用场景" class="headerlink" title="闭包的应用场景"></a>闭包的应用场景</h4><p>接下来，我们来总结下，闭包的常用场景。</p><p>延迟函数setTimeout<br>我们知道setTimeout的第一个参数是一个函数，第二个参数则是延迟的时间。在下面例子中，</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'this is test.'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">var</span> timer <span class="token operator">=</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>执行上面的代码，变量timer的值，会立即输出出来，表示setTimeout这个函数本身已经执行完毕了。但是一秒钟之后，fn才会被执行。这是为什么？</p><p>按道理来说，既然fn被作为参数传入了setTimeout中，那么fn将会被保存在setTimeout变量对象中，setTimeout执行完毕之后，它的变量对象也就不存在了。可是事实上并不是这样。至少在这一秒钟的事件里，它仍然是存在的。这正是因为闭包。</p><p>很显然，这是在函数的内部实现中，setTimeout通过特殊的方式，保留了fn的引用，让setTimeout的变量对象，并没有在其执行完毕后被垃圾收集器回收。因此setTimeout执行结束后一秒，我们任然能够执行fn函数。</p><ul><li><p><strong>柯里化</strong><br>在函数式编程中，利用闭包能够实现很多炫酷的功能，柯里化算是其中一种。关于柯里化，我会在以后详解函数式编程的时候仔细总结。</p></li><li><p><strong>模块</strong><br>在我看来，模块是闭包最强大的一个应用场景。如果你是初学者，对于模块的了解可以暂时不用放在心上，因为理解模块需要更多的基础知识。但是如果你已经有了很多JavaScript的使用经验，在彻底了解了闭包之后，不妨借助本文介绍的作用域链与闭包的思路，重新理一理关于模块的知识。这对于我们理解各种各样的设计模式具有莫大的帮助。</p></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>num1 <span class="token operator">?</span> num1 <span class="token punctuation">:</span> a<span class="token punctuation">;</span>        <span class="token keyword">var</span> num2 <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>num2 <span class="token operator">?</span> num2 <span class="token punctuation">:</span> b<span class="token punctuation">;</span>        <span class="token keyword">return</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    window<span class="token punctuation">.</span>add <span class="token operator">=</span> add<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在上面的例子中，我使用函数自执行的方式，创建了一个模块。add是模块对外暴露的一个公共方法。而变量a，b被作为私有变量。在面向对象的开发中，我们常常需要考虑是将变量作为私有变量，还是放在构造函数中的this中，因此理解闭包，以及原型链是一个非常重要的事情。</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjt3s6ykj30yg0hddjr.jpg" alt=""></p><p>为了验证自己有没有搞懂作用域链与闭包，这里留下一个经典的思考题，常常也会在面试中被问到。</p><p>利用闭包，修改下面的代码，让循环输出的结果依次为1， 2， 3， 4， 5</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> i<span class="token operator">*</span><span class="token number">1000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><hr><p><strong><em>本文仅作为个人的随身读书笔记收集，没有用于任何商业盈利范畴。如若有侵犯源作者的著作权，请联系本人（立马撤文）<a href="mailto:mstarzheng@foxmail.com" target="_blank" rel="noopener">mstarzheng@foxmail.com</a></em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端面试总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桂林电子科技大学 </tag>
            
            <tag> mstar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初雪の恋</title>
      <link href="/Love/Love/"/>
      <url>/Love/Love/</url>
      
        <content type="html"><![CDATA[<center>择一城终老，遇一人白首</center><br><hr><br><hr><br><center>苦情痣</center><center><br>你说<br>你的颈后有一颗苦情痣。<br><br>你说<br>那是因为你不愿忘记前世的爱人。<br><br>你说<br>我们不是初识，而是重新认出了彼此。<br><br>你说<br>我就是你前世的挚爱，<br>所以，<br>今生今世我们命中注定要在一起。<br><br>前世挚爱，今世重逢。<br>莫失莫忘，不离不弃。<br><br>一切都是命中注定的，<br>一切都是最好的安排，<br>一切都刚刚好。<br><br>今生今世，<br>能与你再度相遇，<br>就是我最大的幸运。<br></center><center>缘起 – 扬州鉴真图书馆</center><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjyg3ahfj33k02o07wk.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjyqfxp3j33k02o0npf.jpg" alt=""></p><center>懵懂的恋爱</center><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjz0za1gj33k02o04qr.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjz7p4kzj33k02o07wj.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjzehlzfj33k02o0e85.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjzlr20dj32o03k07wl.jpg" alt=""></p><center>寻找自己 — 无锡大觉寺</center><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2cjzu6x80j32o03k01l0.jpg" alt=""></p><center>相思之路</center><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck027ge4j32o03k0hdv.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck0d103lj32wb4chb2b.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck0jgxzwj30rs0ku1kx.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck0tb9gwj30zk0yttah.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck13u2gtj30xf0zkn0i.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck2l47wjj30go0m8ac7.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck2qvxl8j30zk0qowjb.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck2zmk3qj32o03k0e87.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck36tx4cj33344mou0x.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck3dqfr1j32o03k0u0z.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck3kd4aaj31w02ionpd.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck3rj9axj31z41hcu10.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck3xtjpwj31w02ionpd.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Love </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>摆脱项目命名困难的尴尬局面</title>
      <link href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%91%86%E8%84%B1%E9%A1%B9%E7%9B%AE%E5%91%BD%E5%90%8D%E5%9B%B0%E9%9A%BE%E7%9A%84%E5%B0%B4%E5%B0%AC%E5%B1%80%E9%9D%A2/"/>
      <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%91%86%E8%84%B1%E9%A1%B9%E7%9B%AE%E5%91%BD%E5%90%8D%E5%9B%B0%E9%9A%BE%E7%9A%84%E5%B0%B4%E5%B0%AC%E5%B1%80%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<center>本文源出于—掘金<a href="https://juejin.im/post/58d0e5caa22b9d00643e8b51" target="_blank" rel="noopener"><strong>西安小哥</strong></a></center><h2 id="1、文件夹命名"><a href="#1、文件夹命名" class="headerlink" title="1、文件夹命名"></a><strong>1、文件夹命名</strong></h2><ul><li>1、最好用一个单词描述</li></ul><table><thead><tr><th>常用项目命名</th><th>oml、element、master、project、test、vue、iview</th></tr></thead><tbody><tr><td><strong>二级目录</strong></td><td>build、static、config、src、example、base、commeon、issues、assert</td></tr><tr><td><strong>三级目录</strong></td><td>libs、models、plugins、skins、images、css、js</td></tr></tbody></table><ul><li><p>2、如果一个单词描述不了，名词加动词</p><pre class=" language-html"><code class="language-html">color-pick、button-groups、date-picker、option-group、jquery-select、jquery-swiper</code></pre></li><li><p>3、中间用-或者_连接为了方便归类、一目了然</p><blockquote><p>node_models、async-demo、array-union、array-differ、babel-each</p></blockquote><hr></li></ul><h2 id="2、文件命名"><a href="#2、文件命名" class="headerlink" title="2、文件命名"></a><strong>2、文件命名</strong></h2><ul><li>1.最好用一个单词描述<br>一下变量名可以加css、js、html、例如index.html、index.js、index.css</li></ul><table><thead><tr><th>常用组件命名</th><th>index、message、menu、slider（滑块）、page、progress（进度条）、tooltip（提示）、tree、upload、time、button、checkbox、dialog、cascader（三级联动）</th></tr></thead><tbody><tr><td>常用文件命名</td><td>index、shopping（购物）、 share（分享）、integral（积分）、advertisement（广告）、pay（支付）、community（社区）、game、docs、bussiness</td></tr></tbody></table><ul><li><p>2.如果一个单词描述不了，名词加动词</p><pre class=" language-html"><code class="language-html">share-to-friends，share-to-community，weex-pay，alipay-pay，user-integral，game-page，docs-page等等反正就是自我想象。</code></pre></li><li><p>3.中间用-或者_连接为了方便归类、一目了然<br>在目前做的pc端和移动端，简单的对他们分个类：</p></li></ul><pre class=" language-html"><code class="language-html">移动广告(mobile-advertisement)移动社交(mobile-social)移动电子商务(mobile-bussiness)手机游戏(mobile-game)手机电视(mobile-tv)移动电子阅读(mobile-reading)手机搜索(mobile-search)移动支付(mobile-pay)手机内容共享(mobile-share)</code></pre><p>关于以上的项目都可以用名词+需要的动词命名，达到见词知意</p><hr><h2 id="3-html布局命名"><a href="#3-html布局命名" class="headerlink" title="3.html布局命名"></a><strong>3.html布局命名</strong></h2><p><a href="http://www.divcss5.com/jiqiao/j4.shtml" target="_blank" rel="noopener"><strong>可以参考DIV+CSS规范命名大全</strong></a> 但是我觉得写得并不好，很全面。因为因为往往比较纠结的是每一个大布局中小布局的命名。</p><pre class=" language-html"><code class="language-html">外套 wrap:       >> #container头部 header:     >> #head, #header，#nav，#sub-nav，#menu， #sub-menu，#branding主要内容 main::   >> bussiness-title 、bussiness-logo、bussiness-search、bussiness-search-results左侧 main-left:  >> #side-bar, #side-bar-a, #side-bar-b右侧 main-right: >> #side-bar, #side-bar-a, #side-bar-b内容 content:    >> radio-click、radio-heightlight、radio-active、input-seach-off、input-search-on底部 footer:     >> #service, #regsiter,#partner（合作伙伴）,#joinus, #site-info</code></pre><blockquote><p>总结</p></blockquote><pre class=" language-html"><code class="language-html">一般头部有nav、nav-event、nav-style、nav-item、nav-link。内容：xx-title、xx-box、xx-warp、xx-item、xx-item-title、xx-item-link、xx-item-image底部：footer-time、footer-box、footer-item、footer-item-link、footer-address。总之xx-wrap，xx-box，xx-item、xx-link、xx-title、xx-total肯定会满足你80%的需求</code></pre><hr><h2 id="4、js变量命名"><a href="#4、js变量命名" class="headerlink" title="4、js变量命名"></a><strong>4、js变量命名</strong></h2><ul><li>1.基础类型和引用数据类型</li></ul><pre class=" language-javascript"><code class="language-javascript"> 基础类型 字符串<span class="token keyword">var</span> s_count<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">,</span> 布尔类型<span class="token keyword">var</span> b_status<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">,</span> 数字类型<span class="token keyword">var</span> n_total<span class="token operator">=</span><span class="token number">12</span>。 引用数据类型 数组<span class="token keyword">var</span> ar_bar<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> 对象<span class="token keyword">var</span> o_bar<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> 函数<span class="token keyword">var</span> f_submit<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>）</code></pre><ul><li><p>2.不要用关键字命名<br>default、class、private</p></li><li><p>3.用可读的同义词代替保留词。</p></li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// bad</span><span class="token keyword">var</span> superman <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token keyword">class</span><span class="token punctuation">:</span> <span class="token string">'alien'</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// bad</span><span class="token keyword">var</span> superman <span class="token operator">=</span> <span class="token punctuation">{</span>  klass<span class="token punctuation">:</span> <span class="token string">'alien'</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// good</span><span class="token keyword">var</span> superman <span class="token operator">=</span> <span class="token punctuation">{</span>  type<span class="token punctuation">:</span> <span class="token string">'alien'</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul><li>4.函数用驼峰形式（动词+名词）</li></ul><pre class=" language-html"><code class="language-html"> login(),logout(),expandList(),getTotal(),keySearch(),submitForm(),cancel(),goMore(),searchAll(),searchCurrent().clearContent().uploadImage().searchResult()这些都是常用事件，可以清晰知道每一项的意义。</code></pre><p><a href="https://github.com/airbnb/javascript/tree/es5-deprecated/es5" target="_blank" rel="noopener">ES5的语法规范</a></p><ul><li>5.当命名的构造函数和类使用PascalCase。</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// bad</span><span class="token keyword">function</span> <span class="token function">user</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> options<span class="token punctuation">.</span>name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> bad <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">user</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">'nope'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// good</span><span class="token keyword">function</span> <span class="token function">User</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> options<span class="token punctuation">.</span>name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> good <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">'yup'</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><ul><li>6.不要使用尾随或前导下划线。</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// bad</span><span class="token keyword">this</span><span class="token punctuation">.</span>__firstName__ <span class="token operator">=</span> <span class="token string">'Panda'</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>firstName_ <span class="token operator">=</span> <span class="token string">'Panda'</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>_firstName <span class="token operator">=</span> <span class="token string">'Panda'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// good</span><span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> <span class="token string">'Panda'</span><span class="token punctuation">;</span></code></pre><ul><li>7.前缀jQuery对象变量与$。</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// bad</span><span class="token keyword">var</span> sidebar <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.sidebar'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// good</span><span class="token keyword">var</span> $sidebar <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.sidebar'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// bad</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">,</span> <span class="token string">'.sidebar'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// bad</span><span class="token keyword">function</span> <span class="token function">setSidebar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.sidebar'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ...stuff...</span>  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.sidebar'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token string">'background-color'</span><span class="token punctuation">:</span> <span class="token string">'pink'</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// good</span><span class="token keyword">function</span> <span class="token function">setSidebar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> $sidebar <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.sidebar'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  $sidebar<span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ...stuff...</span>  $sidebar<span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token string">'background-color'</span><span class="token punctuation">:</span> <span class="token string">'pink'</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// bad</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.sidebar'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// good</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.sidebar ul'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// good</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.sidebar > ul'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// good</span>$sidebar<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><hr><h2 id="5-css命名"><a href="#5-css命名" class="headerlink" title="5.css命名"></a><strong>5.css命名</strong></h2><table><thead><tr><th>公共的</th><th>common.css</th></tr></thead><tbody><tr><td>其实和common差不多</td><td>base.css</td></tr><tr><td>动画</td><td>animation.css</td></tr><tr><td>皮肤</td><td>skin.css</td></tr><tr><td>文字</td><td>font.css</td></tr><tr><td>主题</td><td>themes.css</td></tr><tr><td>打印样式</td><td>print.css</td></tr><tr><td>颜色</td><td>color.css</td></tr></tbody></table><hr><h2 id="6-图片命名"><a href="#6-图片命名" class="headerlink" title="6.图片命名"></a><strong>6.图片命名</strong></h2><pre class=" language-html"><code class="language-html">第一部分是图片的逻辑归属分类第二部分是图片的表现内容第三部分是图片的内容的类型（有些图片还会有第四部分，表示图片表现的状态。）tabbar_home_icon, navigationbar_showtime_icon@2x.png，tabbar_categories_icon</code></pre><hr><p><strong><em>本文仅作为个人的随身读书笔记收集，没有用于任何商业盈利范畴。如若有侵犯源作者的著作权，请联系本人（立马撤文）<a href="mailto:mstarzheng@foxmail.com" target="_blank" rel="noopener">mstarzheng@foxmail.com</a></em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桂林电子科技大学 </tag>
            
            <tag> mstar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针解谜</title>
      <link href="/Objective-C%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/pointer/"/>
      <url>/Objective-C%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/pointer/</url>
      
        <content type="html"><![CDATA[<p><center>本文源出于—<a href="http://www.cnblogs.com/mjios/archive/2013/03/16/2963645.html" target="_blank" rel="noopener"><strong>小码哥</strong></a></center></p><p><hr></p><h2 id="一、什么是指针"><a href="#一、什么是指针" class="headerlink" title="一、什么是指针"></a>一、什么是指针</h2><p>1.我们已经知道，“直接引用”是直接通过变量名来读写变量<br>2.C语言还有一种“间接引用”的方式(以变量a为例)：<font color="red"><strong>_ 首先将变量a的地址存放在另一个变量中，比如存放变量b中，然后通过变量b来间接引用变量，间接读写变量a的值 _</strong> </font>。这就是“间接引用”。</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck6v711uj309002a74c.jpg" alt=""></p><p>如果程序通过”间接引用”的方式来修改a的值，可以这样做：先根据变量名b 获取 变量b的地址ffc2，取出变量b中存储的内容ffc1，也就是变量a的地址，再根据变量a的地址ffc1找到a的存储空间，然后修改里面的数据。</p><p>3.总结一句：用来存放<font color="red">变量地址</font>的变量，就称为”指针变量”。在上面的情况下，变量b就是个”指针变量”，我们可以说指针变量b指向变量a。</p><p><hr></p><h2 id="二、指针定义"><a href="#二、指针定义" class="headerlink" title="二、指针定义"></a>二、指针定义</h2><p>一般形式：<strong> 类名标识符   <font color="red">*</font> 指针变量名；</strong></p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token keyword">float</span> <span class="token operator">*</span>q<span class="token punctuation">;</span></code></pre><p>“<font color="red">*</font>“是一个说明符，用来说明这个变量是个指针变量，是不能省略的，但它不属于变量名的一部分<br>前面的类型标识符表示指针变量所指向的变量的类型，而且只能指向这种类型的变量</p><p><hr></p><h2 id="三、指针的初始化"><a href="#三、指针的初始化" class="headerlink" title="三、指针的初始化"></a>三、指针的初始化</h2><h3 id="1-先定义后初始化"><a href="#1-先定义后初始化" class="headerlink" title="1.先定义后初始化"></a>1.先定义后初始化</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 定义int类型的变量a</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 定义一个指针变量p</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 将变量a的地址赋值给指针变量p，所以指针变量p指向变量a</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span></code></pre><p>注意第8行，赋值给p的是变量a的地址&amp;a</p><h3 id="2-在定义的同时初始化"><a href="#2-在定义的同时初始化" class="headerlink" title="2.在定义的同时初始化"></a>2.在定义的同时初始化</h3><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 定义int类型的变量a</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 定义一个指针变量p</span><span class="token comment" spellcheck="true">// 并将变量a的地址赋值给指针变量p，所以指针变量p指向变量a</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span></code></pre><h3 id="3-初始化的注意"><a href="#3-初始化的注意" class="headerlink" title="3.初始化的注意"></a>3.<font color="red">初始化的注意</font></h3><p>指针变量是用来存放变量地址的，不要给它随意赋值一个常数。下面的写法是错误的</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这是错误的</span></code></pre><p><hr></p><h2 id="四、指针运算符"><a href="#四、指针运算符" class="headerlink" title="四、指针运算符"></a>四、指针运算符</h2><h3 id="1-给指针指向的变量赋值"><a href="#1-给指针指向的变量赋值" class="headerlink" title="1.给指针指向的变量赋值"></a>1.给指针指向的变量赋值</h3><pre class=" language-c"><code class="language-c"> <span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"修改前，a的值：%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 指针变量p指向变量a</span> <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过指针变量p间接修改变量a的值</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"修改后，a的值：%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p> 当程序刚执行完第5行代码时，内存中大概的分布情况是这样的</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck75ulngj3099039wel.jpg" alt=""><br>a值是10，p值就是变量a的地址ffc3。</p><p>注意下第5、第8行，都有个“<font color="red">*</font>”，它们的含义是不一样的：</p><ul><li>第5行的“<font color="red">*</font>”只是用来说明p是个指针变量</li><li>第8行的<font color="red">“星号”</font>是一个指针运算符，这里的<font color="red">* p代表根据p值ffc3这个地址访问对应的存储空间</font>，也就是变量a的存储空间，然后将右边的数值9写入到这个存储空间，相当于 a = 9;，于是内存中就变成这样了</li></ul><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck7ewd9bj308z02zjrh.jpg" alt=""><br>输出结果为：</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck7mrc1uj305501k747.jpg" alt=""><br>可以发现，我们通过变量p间接修改了变量a的值。</p><h3 id="2-取出指针所指向变量的值"><a href="#2-取出指针所指向变量的值" class="headerlink" title="2.取出指针所指向变量的值"></a>2.取出指针所指向变量的值</h3><p>指针运算符除了可以赋值之外，还可以用于取值</p><pre class=" language-c"><code class="language-c"> <span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token keyword">char</span> value <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"取出a的值：%d"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出结果：<br><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck7vxznsj304100zt8k.jpg" alt=""><br>第6行中的<font color="red">*p</font>的意思是：根据p值(即变量a的地址)访问对应的存储空间，并取出存储的内容(即取出变量a的值)，赋值给value</p><h3 id="3-使用注意"><a href="#3-使用注意" class="headerlink" title="3.使用注意"></a>3.使用注意</h3><p>在指针变量没有指向确定地址之前，不要对它所指的内容赋值。下面的写法是错误的</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这是错误的</span></code></pre><p>应该在指针变量指向一个确定的变量后再进行赋值。下面的写法才是正确的</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 定义2个int型变量</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span> b<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 定义一个指向变量b的指针变量p</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 将a的值赋值给变量b</span><span class="token operator">*</span>p <span class="token operator">=</span> a<span class="token punctuation">;</span></code></pre><hr><h2 id="五、指针的用途举例"><a href="#五、指针的用途举例" class="headerlink" title="五、指针的用途举例"></a>五、指针的用途举例</h2><h3 id="1-例子1"><a href="#1-例子1" class="headerlink" title="1.例子1"></a>1.例子1</h3><p>前面我们通过指针变量p间接访问了变量a，在有些人看来，觉得指针变量好傻B，直接用变量名a访问变量a不就好了么，干嘛搞这么麻烦。别着急，接下来举个例子，让大家看看指针还能做什么事情。</p><p>现在有个要求：写一个函数swap，接收2个整型参数，功能是互换两个实参的值。</p><p>1&gt; 如果没学过指针，你可能会这样写</p><pre class=" language-c"><code class="language-c"> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">char</span> v1<span class="token punctuation">,</span> <span class="token keyword">char</span> v2<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"更换前：v1=%d, v2=%d\n"</span><span class="token punctuation">,</span> v1<span class="token punctuation">,</span> v2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 定义一个中间变量</span>    <span class="token keyword">char</span> temp<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 交换v1和v2的值</span>     temp <span class="token operator">=</span> v1<span class="token punctuation">;</span>     v1 <span class="token operator">=</span> v2<span class="token punctuation">;</span>     v2 <span class="token operator">=</span> temp<span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"更换后：v1=%d, v2=%d\n"</span><span class="token punctuation">,</span> v1<span class="token punctuation">,</span> v2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"更换前：a=%d, b=%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"更换后：a=%d, b=%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>输出结果：<br><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck87a0p5j306502q0sv.jpg" alt=""><br>虽然v1和v2的值被交换了，但是变量a和b的值根本就没有换过来。因为基本数据类型作为函数实参时，只是纯粹地将值传递给形参，形参的改变并不影响实参。<br>我们可以简要分析一下这个过程：</p><blockquote><p>在第20行中，将变量a、b的值分别传递给了swap函数的两个形参v1、v2</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck8fsp45j309903pwep.jpg" alt=""></p><blockquote><p>在第8行中，将v1的值赋值给了temp</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck8yn16rj309j04vdg5.jpg" alt=""></p><blockquote><p>在第9行中，将v2的值赋值给了v1</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ck97tdx8j309h04lmxg.jpg" alt=""></p><blockquote><p>在第10行中，将temp的值赋值给了v2</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ckae1y9xj309f04omxg.jpg" alt=""></p><p>就这样，v1和v2的值被交换了，但是a和b的值一直都没有改变</p><p>2&gt; 如果学了指针，就应该这样写</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>v1<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>v2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 中间变量</span>    <span class="token keyword">char</span> temp<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 取出v1指向的变量的值</span>     temp <span class="token operator">=</span> <span class="token operator">*</span>v1<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 取出v2指向的变量的值，然后赋值给v1指向的变量</span>     <span class="token operator">*</span>v1 <span class="token operator">=</span> <span class="token operator">*</span>v2<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 赋值给v2指向的变量</span>     <span class="token operator">*</span>v2 <span class="token operator">=</span> temp<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"更换前：a=%d, b=%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"更换后：a=%d, b=%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>先看看输出结果：</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ckaobv3bj305701fdfq.jpg" alt=""><br>变量a和b的值终于换过来了。</p><font color="red">解释一下：(在16位编译器环境下，一个指针变量占用2个字节)</font><blockquote><p>先注意第20行，传递是变量的地址。因此swap函数的形参v1指向了变量a，v2指向了变量b</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ckawh7plj309d054aae.jpg" alt=""></p><blockquote><p> 第6行代码是取出v1指向的变量的值，也就是变量a的值：10，然后赋值给变量temp</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ckb39qluj309i05pq3b.jpg" alt=""></p><blockquote><p>第9行代码是取出v2指向的变量(变量b)的值，然后赋值给v1指向的变量(变量a)</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ckbac3plj309705wq37.jpg" alt=""></p><blockquote><p>第12行代码是将temp变量的值赋值给v2指向的变量(变量b)</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ckec7tfgj309b05st90.jpg" alt=""><br>相信你已经感受到指针的强大了，如果没有指针，在一个函数的内部根本改变不了外部的实参。</p><h3 id="2-例子2"><a href="#2-例子2" class="headerlink" title="2.例子2"></a>2.例子2</h3><p>接下来再举一个指针的实用例子。默认情况下，一个函数只能有一个返回值，有了指针，我们可以实现函数有”多返回值”。</p><p>现在有个要求：写一个函数sumAndMinus，可以同时计算2个整型的和与差，函数执行完毕后，返回和与差(注意了，这里要返回2个值)</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 计算2个整型的和与差</span><span class="token keyword">int</span> <span class="token function">sumAndMinus</span><span class="token punctuation">(</span><span class="token keyword">int</span> v1<span class="token punctuation">,</span> <span class="token keyword">int</span> v2<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>minus<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 计算差，并赋值给指针指向的变量</span>    <span class="token operator">*</span>minus <span class="token operator">=</span> v1 <span class="token operator">-</span> v2<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 计算和，并返回和</span>    <span class="token keyword">return</span> v1 <span class="token operator">+</span> v2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 定义2个int型变量</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 定义2个变量来分别接收和与差</span>    <span class="token keyword">int</span> sum<span class="token punctuation">,</span> minus<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用函数</span>    sum <span class="token operator">=</span> <span class="token function">sumAndMinus</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>minus<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 打印和</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d+%d=%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 打印差</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d-%d=%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> minus<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输出结果：<br><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ckeqmw7xj302101h3yb.jpg" alt=""><br>和与差都由同一个函数计算并返回出来。和是函数的直接返回值，差是通过函数的第3个指针参数间接返回。因此有了指针，我们可以让函数有”无限个”返回值。</p><hr><h2 id="六、关于指针的疑问"><a href="#六、关于指针的疑问" class="headerlink" title="六、关于指针的疑问"></a>六、关于指针的疑问</h2><p>刚学完指针，都可能有一大堆的疑惑，这里我列出几个常见的疑惑吧。</p><p><strong> 1.一个指针变量占用多少个字节的内存空间？占用的空间是否会跟随所指向变量的类型而改变？</strong></p><p>在同一种编译器环境下，一个指针变量所占用的内存空间是固定的。比如，在16位编译器环境下，任何一个指针变量都只占用2个字节，并不会随所指向变量的类型而改变。</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ckf0qz17j30ew02cdg4.jpg" alt=""><br><strong> 2.既然每个指针变量所占用的内存空间是一样的，而且存储的都是地址，为何指针变量还要分类型？而且只能指向一种类型的变量？比如指向int类型的指针、指向char类型的指针。 </strong></p><p>其实，我觉得这个问题跟”数组为什么要分类型”是一样的。</p><blockquote><ul><li>看下面的代码，利用指针p读取变量c的值</li></ul></blockquote><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 定义一个指向char类型的指针</span> <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 取出</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这个输出结果应该难不倒大家：<strong> 1 </strong>，是可以成功读取的。</p><ul><li>如果我改一下第5行的代码，用一个本应该指向int类型变量的指针p，指向char类型的变量c</li></ul><blockquote><p>int *p = &c;</p></blockquote><p>我们再来看一下输出：<strong> 513 </strong>，c的原值是1，现在取出来却是513，怎么回事呢？这个要根据内存来分析</p><p>根据变量的定义顺序，这些变量在内存中大致如下图排布：</p><p>其中，指针变量p和int类型变量i各占2个字节，char类型的c占一个字节，p指向c，因此p值就是c的地址</p><p><img src="https://ws1.sinaimg.cn/large/007BZ0QOly1g2ckf9hghuj309w04k0t0.jpg" alt=""><br>1&gt; 最初的时候，我们用char <em>p指向变量c。当利用</em>p来获取变量c的值时，由于指针p知道变量c是char类型的，所以会从ffc3这个地址开始读取1个字节的数据：0000 0001，转为10进制就是1</p><p>2&gt; 后来，我们用int <em>p指向变量c。当利用</em>p获取变量c的值时，由于指针p认为变量c是int类型的，所以会从ffc3这个地址开始读取2个字节的数据：0000 0010 0000 0001，转为10进制就是513</p><p>可见，给指针分类是多么重要的一件事，而且一种指针最好只指向一种类型的变量，那是最安全的。</p><hr><p><strong><em>本文仅作为个人的随身读书笔记收集，没有用于任何商业盈利范畴。如若有侵犯源作者的著作权，请联系本人（立马撤文）<a href="mailto:mstarzheng@foxmail.com" target="_blank" rel="noopener">mstarzheng@foxmail.com</a></em></strong></p>]]></content>
      
      
      <categories>
          
          <category> Objective-C学习整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桂林电子科技大学 </tag>
            
            <tag> mstar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试集结号---HTML</title>
      <link href="/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B-HTML/"/>
      <url>/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B-HTML/</url>
      
        <content type="html"><![CDATA[<h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><blockquote><p>web标准、web语义、浏览器内核、兼容性、html5…</p></blockquote><p><hr></p><h1 id="常见面试问题-amp-答案"><a href="#常见面试问题-amp-答案" class="headerlink" title=" 常见面试问题&amp;答案 "></a><strong> 常见面试问题&amp;答案 </strong></h1><p><hr><br><strong>1、Doctype作用？严格模式与混杂模式如何区分？它们有何意义?</strong></p><pre class=" language-javascritp"><code class="language-javascritp"><!DOCTYPE>声明位于HTML文档中的第一行，处于<html>标签之前，用于告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。如果HTML文档包含形式完整的DOCTYPE，那么他一般以标准模式呈现。对于HTML4.01文档，包含严格DTD的DOCTYPE常常导致页面已标准模式呈现。DOCTYPE不存在或者格式不正确会导致文档已混杂模式呈现。</code></pre><p><strong>2、请描述一个网页从开始请求道最终显示的完整过程</strong></p><blockquote><p>一个网页从请求到最终显示的完整过程一般可以分为如下7个步骤：</p></blockquote><pre class=" language-javascript"><code class="language-javascript">在浏览器中输入网址；发送至DNS服务器并获得域名对应的WEB服务器IP地址；与WEB服务器建立TCP连接；浏览器向WEB服务器的IP地址发送相应的HTTP请求；WEB服务器响应请求并返回指定URL的数据，或错误信息，如果设定重定向，则重定向到新的URL地址；浏览器下载数据后解析HTML源文件，解析的过程中实现对页面的排版，解析完成后在浏览器中显示基础页面；分析页面中的超链接并显示在当前页面，重复以上过程直至无超链接需要发送，完成全部数据显示。</code></pre><p><strong>3、HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;</strong></p><pre class=" language-javascript"><code class="language-javascript">HTML5不基于SGML，因此不需要对DTD进行引用，但是需要DOCTYPE来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；HTML4<span class="token number">.01</span>基于SGML，所以需要对DTD进行引用，才能让浏览器知道该文档所使用的文档类型。</code></pre><p><strong>4、行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</strong></p><pre class=" language-javascript"><code class="language-javascript">  <span class="token operator">**</span><span class="token operator">*</span>行内元素<span class="token operator">**</span><span class="token operator">*</span>：a <span class="token operator">-</span> 锚点，em <span class="token operator">-</span> 强调，strong <span class="token operator">-</span> 粗体强调，span <span class="token operator">-</span> 定义文本内区块，i <span class="token operator">-</span> 斜体<span class="token punctuation">,</span>img <span class="token operator">-</span> 图片<span class="token punctuation">,</span>b <span class="token operator">-</span> 粗体，label <span class="token operator">-</span> 表格标签，select <span class="token operator">-</span> 项目选择，textarea <span class="token operator">-</span> 多行文本输入框，sub <span class="token operator">-</span> 下标，sup <span class="token operator">-</span> 上标，q <span class="token operator">-</span> 短引用；  <span class="token operator">**</span><span class="token operator">*</span>块元素<span class="token operator">**</span><span class="token operator">*</span>：div <span class="token operator">-</span> 常用块级，dl <span class="token operator">-</span> 定义列表，dt，dd，ul<span class="token operator">-</span> 非排序列表，li，ol<span class="token operator">-</span>排序表单，p<span class="token operator">-</span>段落，h1，h2，h3，h4，h5<span class="token operator">-</span>标题，table<span class="token operator">-</span>表格，fieldset <span class="token operator">-</span> form控制组，form <span class="token operator">-</span> 表单，  <span class="token operator">**</span><span class="token operator">*</span>空元素<span class="token operator">**</span><span class="token operator">*</span>：br<span class="token operator">-</span>换行，hr<span class="token operator">-</span>水平分割线；</code></pre><p><strong>5、介绍一下你对浏览器内核的理解</strong></p><pre class=" language-javascript"><code class="language-javascript">浏览器最重要或者说核心的部分是“Rendering Engine”，可大概译为“渲染引擎”，不过我们一般习惯将之称为“浏览器内核”。负责对网页语法的解释（如标准通用标记语言下的一个应用HTML、JavaScript）并渲染（显示）网页。 所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因。</code></pre><p><strong>6、常见的浏览器内核有哪些</strong></p><pre class=" language-javascript"><code class="language-javascript">Trident内核：IE<span class="token punctuation">,</span>MaxThon<span class="token punctuation">,</span>TT<span class="token punctuation">,</span>The World<span class="token punctuation">,</span><span class="token number">360</span><span class="token punctuation">,</span>搜狗浏览器等。<span class="token punctuation">[</span>又称MSHTML<span class="token punctuation">]</span>Gecko内核：Netscape6及以上版本，FF<span class="token punctuation">,</span>MozillaSuite<span class="token operator">/</span>SeaMonkey等。Presto内核：Opera7及以上。      <span class="token punctuation">[</span>Opera内核原为：Presto，现为：Blink<span class="token punctuation">;</span><span class="token punctuation">]</span>Webkit内核：Safari<span class="token punctuation">,</span>Chrome等。   <span class="token punctuation">[</span> Chrome的：Blink（WebKit的分支）<span class="token punctuation">]</span>EdgeHTML内核：Microsoft Edge。  <span class="token punctuation">[</span>此内核其实是从MSHTML fork而来，删掉了几乎所有的IE私有特性<span class="token punctuation">]</span></code></pre><p><strong>7、html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 </strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">**</span><span class="token operator">*</span>新增了以下的几大类元素<span class="token operator">**</span><span class="token operator">*</span>内容元素，article、footer、header、nav、section。表单控件，calendar、date、time、email、url、search。控件元素，webworker<span class="token punctuation">,</span> websockt<span class="token punctuation">,</span> Geolocation。<span class="token operator">**</span><span class="token operator">*</span>移出的元素有下列这些<span class="token operator">**</span><span class="token operator">**</span>显现层元素：basefont，big，center，font<span class="token punctuation">,</span> s，strike，tt，u。性能较差元素：frame，frameset，noframes。HTML5已形成了最终的标准，概括来讲，它主要是关于图像，位置，存储，多任务等功能的增加。新增的元素有绘画 canvas ，用于媒介回放的 video 和 audio 元素，本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失，而sessionStorage的数据在浏览器关闭后自动删除，此外，还新增了以下的几大类元素。内容元素，article、footer、header、nav、section。表单控件，calendar、date、time、email、url、search。控件元素，webworker<span class="token punctuation">,</span> websockt<span class="token punctuation">,</span> Geolocation。<span class="token operator">**</span><span class="token operator">*</span>移出的元素有下列这些<span class="token operator">**</span><span class="token operator">*</span>显现层元素：basefont，big，center，font<span class="token punctuation">,</span> s，strike，tt，u。性能较差元素：frame，frameset，noframes。<span class="token operator">**</span><span class="token operator">*</span>新的技术<span class="token operator">**</span><span class="token operator">*</span>canvas<span class="token punctuation">,</span>svg<span class="token punctuation">,</span>webworker<span class="token punctuation">,</span> websocket<span class="token punctuation">,</span> Geolocation<span class="token operator">...</span><span class="token operator">...</span></code></pre><p><strong>8、简述一下你对HTML语义化的理解</strong></p><pre class=" language-javascript"><code class="language-javascript">HTML语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；即使在没有样式CSS的情况下也能以一种文档格式显示，并且是容易阅读的；搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，有利于SEO；使阅读源代码的人更容易将网站分块，便于阅读、维护和理解。</code></pre><p><strong>9、HTML5的离线存储怎么使用？能否解释一下工作原理</strong></p><blockquote><p>在用户没有连接英特网时，可以正常访问站点和应用；在用户连接英特网时，更新用户机器上的缓存文件。<br><strong><code>原理</code></strong>：HTML5的离线存储是基于一个新建的 <code>.appcache</code> 文件的缓存机制（并非存储技术），通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储下来。之后当网络处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。<br>使用方法</p></blockquote><pre class=" language-javascript"><code class="language-javascript">在页面头部像下面一样加入一个 manifest 的属性；在 cache<span class="token punctuation">.</span>manifest 文件里编写离线存储资源；   CACHE MANIFEST   #v0<span class="token number">.11</span>   CACHE：     js<span class="token operator">/</span>app<span class="token punctuation">.</span>js     css<span class="token operator">/</span>style<span class="token punctuation">.</span>css   NETWORK<span class="token punctuation">:</span>     resource<span class="token operator">/</span>logo<span class="token punctuation">.</span>png   FALLBACK：     <span class="token operator">/</span> <span class="token operator">/</span>offline<span class="token punctuation">.</span>html在离线状态时，操作 window<span class="token punctuation">.</span>applicationCache 进行需求实现；</code></pre><p><strong>10、浏览器是怎么对HTML5的离线储存资源进行管理和加载的</strong></p><pre class=" language-javascript"><code class="language-javascript">在线情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。离线情况下，浏览器就直接使用离线存储的资源。</code></pre><p><strong>11、请描述一下 cookies，sessionStorage 和 localStorage 的区别</strong></p><pre class=" language-javascript"><code class="language-javascript">Web Storage有两种形式：LocalStorage（本地存储）和sessionStorage（会话存储）。这两种方式都允许开发者使用js设置的键值对进行操作，在在重新加载不同的页面的时候读出它们。这一点与cookie类似。<span class="token operator">></span><span class="token operator">></span> 与cookie不同的是：Web Storage数据完全存储在客户端，不需要通过浏览器的请求将数据传给服务器，因此x相比cookie来说能够存储更多的数据，大概5M左右。<span class="token operator">></span><span class="token operator">></span> LocalStorage和sessionStorage功能上是一样的，但是存储持久时间不一样。LocalStorage：浏览器关闭了数据仍然可以保存下来，并可用于所有同源（相同的域名、协议和端口）窗口（或标签页）；sessionStorage：数据存储在窗口对象中，窗口关闭后对应的窗口对象消失，存储的数据也会丢失。注意：sessionStorage 都可以用localStorage 来代替，但需要记住的是，在窗口或者标签页关闭时，使用sessionStorage 存储的数据会丢失。<span class="token operator">></span><span class="token operator">></span> 使用 local storage和session storage主要通过在js中操作这两个对象来实现，分别为window<span class="token punctuation">.</span>localStorage和window<span class="token punctuation">.</span>sessionStorage<span class="token punctuation">.</span> 这两个对象均是Storage类的两个实例，自然也具有Storage类的属性和方法。</code></pre><p><strong>12、iframe 有哪些缺点</strong></p><pre class=" language-javascript"><code class="language-javascript">iframe会阻塞主页面的Onload事件；搜索引擎的检索程序无法解读这种页面，不利于SEO；iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好通过JavaScript动态给iframe添加src属性值，这样可以绕开以上两个问题。</code></pre><p><strong>13、Label的作用是什么？如何使用</strong></p><pre class=" language-html"><code class="language-html">label标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Number:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Name<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Name<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span>Date:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>B<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span></code></pre><p><strong>14、HTML5的form如何关闭自动完成功能</strong></p><blockquote><p>给不想要提示的 form 或下面某个 input 设置为 <code>autocomplete = off</code>。</p></blockquote><p><strong>15、如何实现浏览器内多个标签页之间的通信？（阿里）</strong></p><blockquote><p>调用 localStorage、cookies 等本地存储方式</p></blockquote><p><strong>16、webSocket 如何兼容低浏览器？（阿里）</strong></p><blockquote><p>Adobe Flash Socket<br>ActiveX HTMLFile（IE）<br>基于 multipart 编码发送 XHR<br>基于长轮询的 XHR</p></blockquote><p><strong>17、页面可见性（Page Visibility） API可以有哪些用途</strong></p><blockquote><p>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放。</p></blockquote><p><strong>18、如何在页面上实现一个圆形的可点击区域？</strong></p><pre class=" language-javascript"><code class="language-javascript">map <span class="token operator">+</span> area 或者 svgborder<span class="token operator">-</span>radius纯js实现，需要求一个点在不在圆上的简单算法、获取鼠标坐标等等</code></pre><p><strong>19、实现 不使用 border 画出 1px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">height</span><span class="token punctuation">:</span><span class="token number">1</span>px<span class="token punctuation">;</span><span class="token property">overflow</span><span class="token punctuation">:</span>hidden<span class="token punctuation">;</span><span class="token property">background</span><span class="token punctuation">:</span><span class="token hexcode">#ccc</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p><strong>20、网页验证码是干什么用的？是为了解决什么安全问题</strong></p><blockquote><p>可以防止：恶意破解密码、刷票、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试，实际上用验证码是现在很多网站通行的方式，我们利用比较简易的方式实现了这个功能。这个问题可以由计算机生成并评判，但是必须只有人类才能解答。由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。</p></blockquote><hr><p><strong><em>本文仅作为个人的随身读书笔记收集，没有用于任何商业盈利范畴。如若有侵犯源作者的著作权，请联系本人（立马撤文）<a href="mailto:mstarzheng@foxmail.com" target="_blank" rel="noopener">mstarzheng@foxmail.com</a></em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端面试总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mstar </tag>
            
            <tag> 南京邮电大学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>话说汉朝四百年的外戚干政史 </title>
      <link href="/%E6%96%87%E5%AD%97%E7%9A%84%E9%AD%85%E5%8A%9B/%E8%AF%9D%E8%AF%B4%E6%B1%89%E6%9C%9D%E5%9B%9B%E7%99%BE%E5%B9%B4%E7%9A%84%E5%A4%96%E6%88%9A%E5%B9%B2%E6%94%BF%E5%8F%B2/"/>
      <url>/%E6%96%87%E5%AD%97%E7%9A%84%E9%AD%85%E5%8A%9B/%E8%AF%9D%E8%AF%B4%E6%B1%89%E6%9C%9D%E5%9B%9B%E7%99%BE%E5%B9%B4%E7%9A%84%E5%A4%96%E6%88%9A%E5%B9%B2%E6%94%BF%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一段时间以来，韩国总统“闺蜜门”的新闻印刷爆微信朋友圈，爆闹得沸沸扬扬。其实朴瑾惠的秘书有大几百号人，这些都是帮她出谋划策的家臣们。那么为什么她还要问政于闺蜜，而“闺蜜干政”事件又怎么会触怒韩国民众呢？对于一位总统问政于闺蜜被人深扒为政治事件这一定有很深的背景，我们今天就姑且不去探讨。其实在朝鲜古代历史和中国封建社会历朝历代家臣干政的事是经常发生的。那么我们今天去扒一扒有着四百多年历史的汉朝皇帝的那些家臣–<strong>外戚是干政的历史吧</strong>。</p><h2 id="一、西汉外戚干政概说"><a href="#一、西汉外戚干政概说" class="headerlink" title="一、西汉外戚干政概说"></a>一、西汉外戚干政概说</h2><p>外戚是指皇帝的母亲和妻子家族，作为与皇室有关联的特殊政治力量，历代在中国政治舞台上扮演者特殊的角色。这种角色是由其特殊身份决定的：其与皇权最为接近，但有距离皇权最远。正是因为皇权的存在使得外戚在历代的政治斗争中往往成为皇权的牺牲品。历代王朝在外戚的任用中也是慎之又慎，以防止皇权旁落。防止外戚对于皇权的窥视成为历代王朝政治斗争的主要任务之一，历代王朝为防止外戚篡权基本上采取不让外戚干政的基本政策。但汉朝却是个例外。</p><p>两汉王朝四百多年的历史中外戚作为特殊的政治力量一直活跃在政治舞台之上，并且一度篡权皇权，建立了外戚政权。这可以说在中国历史上是外戚专权的顶峰。纵观汉朝四百多年的历史，外戚作为特殊的政治力量一直处于汉王朝政权的中心位置，成为掌握实权的政治力量。而且大部分时候成为与皇权并驾齐驱的政治力量，这种政治格局一直持续到东汉末年。可以说外戚在汉朝四百年历史中扮演的角色是以后历代王朝中所不能比拟的，这成为汉朝统治的最大特色。</p><p>西汉朝任用外戚作为权利中心决策者始于汉高祖刘邦，据吕思勉先生之说这是因为汉朝去古代不远，是前代时期的遗风。在汉代政治舞台上存在三股政治势力：皇帝、外戚、功臣。这三股势力中皇帝处于中心地位，皇帝为了维持自己的皇权必须要求有政治势力来支持自己的统治。对于功臣这在其获取江山并在保持江山的稳定中起着至关重要的作用，但功臣就亲属关系上必定属于外人，与皇权本身就存在着矛盾。并且功臣在汉朝政治舞台上本身存在着真实实力，这是对皇权的一种威胁。但外戚不同。外戚是皇帝的姻亲，与皇帝有着血缘的关系，正是这种特殊的关系使得汉朝的皇帝在人事权的任用上偏重于外戚。这种任用外戚似乎成了汉朝的惯例，正如《后汉书·皇后纪》记载：汉兴，舅氏之封侯，犹皇子之为王也。可见汉朝对于外戚的重视。</p><p>西汉朝任用外戚主政也始于汉高祖刘邦之时，《史记·高祖本纪》记载：戚姬幸，常从上之关东，日夜啼泣，欲立其子代太子。吕后年长，常留守，希见上，益疏。汉高祖刘邦在外征伐之时，吕后因年长常常留守后方，主持政务。这似乎成了外戚参政的开端。吕后专权开启了外戚专权的先例。吕后掌握汉朝政权后，为了维持自己的统治任用吕氏家族的人掌握汉朝中央的军政大权。吕氏一族掌握汉室政权，开启了外戚专权的开端，但在汉初朝中的政策方针很多出于吕后之手，诛杀韩信、诛杀彭越，都出于吕后之手。吕后在汉初政权的巩固之中却是起了重要的作用。正是由于吕后才使得汉王朝继续着休养生息，有利于发展封建社会的经济。</p><p>文帝之时，由于其是被功臣拥立继位，并且其母家薄氏势力又弱，因此在外戚重用方面主要是其皇后窦姓一族。我们要说文帝之所以能继承皇位在很大关系上也得益于其母家，因其母家势力弱小，因此在汉初经历了吕后之事后大臣鉴于历史教训，拥立了母家实力弱小的代王刘恒。可见此时功臣与外戚势力在政治斗争中的激烈程度，双方都希望能掌控实权。</p><p>汉景帝时期自然重用其母家窦姓一族，在汉景帝一生中其母窦太后起着重要作用，窦姓一族构成了汉朝中央统治力量的核心，但此时外戚势力远远小于皇权，但在大臣的选用策略上是倾向于外戚的。</p><p>汉武帝初期重用的是自己母家一族，其母亲异性弟弟田蚡一度成为丞相，掌控大权。这时形成了外戚与皇权争夺权力的斗争，在汉武帝时期为加强皇权设置了内朝，这就形成了与丞相为首的官僚集团相对持，使得权力最终落入了皇帝手中。在田蚡之后汉武帝甚至将外戚卫青封为大将军，霍去病封也为将军，这与当时汉武帝武功之治是分不开的，可以说卫氏一族在汉武帝时期达到鼎盛，这是汉武帝重用外戚的结果。</p><p>汉昭帝、汉宣帝、汉元帝等也都在重臣的选择上无疑也倾向于外戚，外戚组成了汉朝统治集团的核心力量。正是这种外戚当权的政策使得在汉成帝时期可谓达到了登峰造极之势，正是从汉成帝时期开始，外戚逐步掌握了汉朝中央大权，最终酿王莽篡汉的惨祸。</p><p>汉成帝继位继封外戚王凤为大司马领尚书事，使得外戚兼有内外朝之职事，权力可谓盛。《汉书·元后传》记载：元帝崩，太子立，是为孝成帝。尊皇后为皇太后，以凤为大司马大将军领尚书事，益封五千户。王氏之兴自凤始。又封太后同母弟崇为安成侯，食邑万户。凤庶弟谭等皆赐爵关内侯，食邑。然而这仅仅只是开头，正是汉成帝的作用，使得外戚势力如日中天，达到前汉前所未有的水平。</p><p>汉成帝河平二年，外戚势力更是更是跃升一层，从此外戚势力更加强大，使得外戚成为权力的真正中心。《元后传》记载：成帝河平二年，上悉封舅谭为平阿侯，商成都侯，立红阳侯，根曲阳侯，逢时高平侯。五人同日封，故世谓之「五侯」。自此王氏子弟皆卿、大夫、侍中、诸曹，分据势官满朝廷。至此，外戚势力直逼皇权。汉成帝死后无嗣，定陶王刘欣继位，是为汉哀帝，汉哀帝是一位颇有作为君主，在其即位之初即刻罢归王氏一族，但其有人用自己祖母、母亲一族是为丁、傅家族。但此时外戚势力不能与王氏同日而语。哀帝有个致命的弱点就是宠幸男宠，甚至打算将汉室江山让与这位男宠董贤，在其继位不就也便死去，其死后无嗣，此时正是这个契机让王氏一族又重掌朝政大权，并最终使得汉王朝走向灭亡。</p><p>汉哀帝死后，太皇太后王氏立刻将皇帝的玉玺收入自己的手中，并立刻让王氏子孙组成新的统治中心。《元后传》记载：　明年，哀帝崩，无子，太皇太后以莽为大司马，与共征立中山王奉哀帝后，是为平帝。帝年九岁，当年被疾，太后临朝，委政于莽。从此，开始了王莽的执政道路，正是王莽使得西汉朝最终覆灭。</p><h2 id="二、东汉西汉外戚干政概说"><a href="#二、东汉西汉外戚干政概说" class="headerlink" title="二、东汉西汉外戚干政概说"></a>二、东汉西汉外戚干政概说</h2><p>东汉王朝初期鉴于前汉王莽的教训，在初期严禁外戚参与中央政权，汉明帝的皇后马皇后因其父是外戚之家不得利于凌云台。这正是对外戚的限制。《后汉书·皇后纪》记载：及帝崩，肃宗即位，尊后曰皇太后。诸贵人当徙居南宫，太后感析别之怀，各赐王赤绶，加安车驷马，白越三千端，杂帛二千匹，黄金十斤。自撰《显宗起居注》，削去兄防参医药事。帝请曰：”黄门舅旦夕供养且一年，既无褒异，又不录勤劳，无乃过乎！”太后曰：”吾不欲令后世闻先帝数亲后宫之家，故不著也。”可见，东汉初统治者对于外戚的防范还是很严的。</p><p>东汉外戚干政开始于汉和帝时期。外戚又进入政治权利之中，这是与后汉此时特殊的政治形态相适应的。自和帝开始汉朝的继位之君大多年幼，这时作为皇帝的母亲–太后做到到历史舞台的前端。汉和帝死后，东汉和熹皇后即邓太后还形成临朝执政16年的局面。根据历史记载，邓太后与班固之妹班昭是闺蜜，在邓太后执政前后，多问政于这位闺蜜。邓太后执政颇有政声，应该与班昭的辅佐分不开。要说起来还真的成就一段闺蜜干政的历史佳话呢。太后执政必然依靠自己的母亲家族，最后就形成了以太后为首的外戚集团。这就形成了外戚集团与皇帝集团在权力上的激烈的斗争。在东汉统治者为了平衡政治力量，在外戚与皇帝的斗争中又出现了一个新的政治势力宦官集团。自和帝开始直到灵帝皇帝、宦官与外戚的斗争交织在一起，甚至形成一种互掐局面。东汉王朝外戚在实力上超过西汉，并且皇帝的废立也由外戚掌握。外戚势力之所以如此强大主要原因在于继位之君年龄弱小，不能亲理朝政，使得朝政大权落入其母后之手，作为妇女其只能依靠自己的母家维持其统治，这就为外戚势力的发展提供了温床。使得外戚的势力在相当长的时期内得到扩张。</p><p>纵观东汉外戚专权的历史，其较西汉势力更是有过之而无不及。由于继位之君年龄的幼小，外戚才能作为特殊血缘关系集团登上政治舞台。在皇帝长成后外戚在政治舞台上已经经营多年，势力远远超过皇权，外朝大臣几乎全为外戚的党羽，皇权往往被架空。皇帝此时在巩固皇权的道路上只有依靠宦官这个集团，最终形成了宦官集团，不过终汉代宦官集团是从属皇帝的，其实力远远在皇权之下，自始至终只是皇权的附属物。</p><h2 id="三、两汉外戚干政的历史影响"><a href="#三、两汉外戚干政的历史影响" class="headerlink" title="三、两汉外戚干政的历史影响"></a>三、两汉外戚干政的历史影响</h2><p>外戚贯穿于汉朝四百年历史，一直在汉朝政治舞台上扮演重要的角色，但前汉后汉的外戚在任用上却有着质的不同。</p><p>西汉在外戚任用上是皇帝根据当时政治平衡而采取的政策，是任用自己血缘亲来加强皇权，外戚在此时只是加强皇权的工具，直到汉平帝时期为止。东汉则是继位之君大多年幼，皇帝母亲执政，只能依靠外戚，这不是皇帝选择的结果，在外戚势力强大之时皇帝的废立也掌握在外戚手中，使得外戚的势力与皇帝形成对抗，并最终皇帝在宦官集团的帮助下将外戚集团将外戚势力铲除。</p><p>外戚集团作为汉朝历史上的特殊政治集团，在汉朝历史舞台上扮演着重要角色。汉朝重用外戚是此后任何王朝所不能比拟的，这与汉王朝建立之时距离秦代不远，宗法血缘思想依然浓厚。正是宗法血缘思想影响统治者才重用与自己有血缘关系的外戚，但正是外戚也使得前汉、后汉陷入了统治危机中，造成一次次内乱，消弱了自身统治力量。尤其是东汉还出现外戚集团和宦官集团互掐的政治局面。使得政治尤为黑暗，最终促成了汉末农民起义，但总的来说这些的出现是由于外戚集团的促使而成的。外戚集团在汉王朝的巩固上虽然起了重要作用，但最后也成为汉王朝的掘墓者。</p><h2 id="四、两汉王朝外戚干政的历史教训"><a href="#四、两汉王朝外戚干政的历史教训" class="headerlink" title="四、两汉王朝外戚干政的历史教训"></a>四、两汉王朝外戚干政的历史教训</h2><p>封建君主专制制度是高度集权的，其负面影响有两个就是政治腐败和决策失误。而决策失误又往往和大权旁落相关。大权旁落时往往又是和外戚干政与宦官专权相连。在中国封建两千多的历史长河中，外戚和宦官交替干政不绝于史书。外戚和宦官这两股政治力量的兴衰都是皇权的副产品。外戚干政几乎贯穿于汉王朝四百多年，外戚集团成为政治舞台上不能忽视的力量。汉朝四百年重用外戚是以后历代王朝所不能比拟的，所造成的政治黑暗也是最惨重的。正是汉朝的惨痛教训才使得以后王朝以此为戒，注意控制外戚势力，这或许是外戚在汉朝四百年历史舞台里留给后世的深刻经验教训吧。</p>]]></content>
      
      
      <categories>
          
          <category> 文字的魅力 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 福建省建阳第一中学 </tag>
            
            <tag> 吴文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue学习笔记</title>
      <link href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近由于项目需要，重新研究起了vue，说到vue，在几个月前就间歇性或多或少有过接触，因为当时用惯了react，有点不习惯vue的模式放弃了，在vue2.0出来后，以及weex的推动，vue的关注度又有了很大的提高，加之项目比较迫切，本来是几个月就该完工的项目，因为种种原因，加上研究生学习繁忙，以后react版本的代码过于复杂，导致后期维护麻烦，遂准备使用vue和apollo进行项目的重写，这篇文章是vue的学习记录</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="上下文问题"><a href="#上下文问题" class="headerlink" title="上下文问题"></a>上下文问题</h2><p>注意，不要在实例属性或者回调函数中（如 <code>vm.$watch(&#39;a&#39;, newVal =&gt; this.myMethod())</code>）使用 <strong>箭头函数</strong>。因为箭头函数绑定父上下文，所以 this 不会像预想的一样是 Vue 实例，而是 <code>this.myMethod</code> 未被定义。</p><h2 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h2><p><code>v-bind</code>:</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 完整语法 <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>a v<span class="token operator">-</span>bind<span class="token punctuation">:</span>href<span class="token operator">=</span><span class="token string">"url"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 缩写 <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>a <span class="token punctuation">:</span>href<span class="token operator">=</span><span class="token string">"url"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span></code></pre><p><code>v-on</code>:</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 完整语法 <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>a v<span class="token operator">-</span>on<span class="token punctuation">:</span>click<span class="token operator">=</span><span class="token string">"doSomething"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 缩写 <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>a @click<span class="token operator">=</span><span class="token string">"doSomething"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span></code></pre><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>在模板中使用绑定表达式很方便，但是只能用于简单的操作，在模板中放入太多的逻辑会让模板变得难以维护，所以对于任何复杂逻辑，都应该使用 <strong>计算属性</strong></p><h2 id="计算缓存vsMethods"><a href="#计算缓存vsMethods" class="headerlink" title="计算缓存vsMethods"></a>计算缓存vsMethods</h2><p>不经过计算属性，我们可以在 method 中定义一个相同的函数来替代它。然而 <strong>不同的是计算属性是基于它的依赖缓存。</strong> 计算属性只有在它的相关依赖发生改变时才会重新取值。</p><h2 id="class与style绑定"><a href="#class与style绑定" class="headerlink" title="class与style绑定"></a>class与style绑定</h2><ol><li>对象语法<pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>div v<span class="token operator">-</span>bind<span class="token punctuation">:</span><span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"{ active: isActive }"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>data<span class="token punctuation">:</span> <span class="token punctuation">{</span>isActive<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre></li><li>数组语法<pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>div v<span class="token operator">-</span>bind<span class="token punctuation">:</span><span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"[activeClass, errorClass]"</span><span class="token operator">></span>data<span class="token punctuation">:</span> <span class="token punctuation">{</span>activeClass<span class="token punctuation">:</span> <span class="token string">'active'</span><span class="token punctuation">,</span>errorClass<span class="token punctuation">:</span> <span class="token string">'text-danger'</span><span class="token punctuation">}</span></code></pre></li></ol><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><ul><li><code>v-if</code>是一个指令，需要将他添加到一个元素上，如果需要切换多个元素可以在多个元素的外面包裹一个 <code>&lt;template&gt;</code>元素，并在上面使用 <code>v-if</code>，<strong>最终的渲染结果中不包含它。</strong></li><li><code>v-show</code>和 <code>v-if</code>的使用方式基本相同，差别在于:<ol><li><code>v-if</code> 是真实的条件渲染，因为它会确保条件块在切换当中适当地销毁与重建条件块内的事件监听器和子组件。</li><li><code>v-if</code> 也是 <strong>惰性</strong> 的：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。</li><li>相比之下， <code>v-show</code> 简单得多——元素始终被编译并保留，只是简单地基于 <strong>CSS 切换</strong> (<code>display: none</code>)。</li></ol></li><li><code>v-else</code>紧跟在 <code>v-if</code>或者 <code>v-show</code>后面才用意义</li></ul><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><ol><li>基本用法<pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>ul id<span class="token operator">=</span><span class="token string">"example-1"</span><span class="token operator">></span><span class="token operator">&lt;</span>li v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"item in items"</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">{</span> item<span class="token punctuation">.</span>message <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span><span class="token keyword">var</span> example1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>el<span class="token punctuation">:</span> <span class="token string">'#example-1'</span><span class="token punctuation">,</span>data<span class="token punctuation">:</span> <span class="token punctuation">{</span> items<span class="token punctuation">:</span> <span class="token punctuation">[</span>   <span class="token punctuation">{</span>message<span class="token punctuation">:</span> <span class="token string">'foo'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>   <span class="token punctuation">{</span>message<span class="token punctuation">:</span> <span class="token string">'Bar'</span> <span class="token punctuation">}</span> <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li>of 替代 in 作为分隔符，因为它是最接近 JavaScript 迭代器的语法<pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>div v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"item of items"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span></code></pre></li><li>如同 <code>v-if</code> 模板，你也可以用带有 v-for 的 <template> 标签来渲染多个元素块<pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>ul<span class="token operator">></span><span class="token operator">&lt;</span>template v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"item in items"</span><span class="token operator">></span> <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">{</span> item<span class="token punctuation">.</span>msg <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span> <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"divider"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span></code></pre></template></li><li><code>v-for</code> 可以通过一个独享的属性来迭代<pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>ul id<span class="token operator">=</span><span class="token string">"repeat-object"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"demo"</span><span class="token operator">></span><span class="token operator">&lt;</span>li v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"value in object"</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">{</span> value <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>el<span class="token punctuation">:</span> <span class="token string">'#repeat-object'</span><span class="token punctuation">,</span>data<span class="token punctuation">:</span> <span class="token punctuation">{</span> object<span class="token punctuation">:</span> <span class="token punctuation">{</span>   FirstName<span class="token punctuation">:</span> <span class="token string">'John'</span><span class="token punctuation">,</span>   LastName<span class="token punctuation">:</span> <span class="token string">'Doe'</span><span class="token punctuation">,</span>   Age<span class="token punctuation">:</span> <span class="token number">30</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>可以提供第二个的参数为键名：<pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>div v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"(value, key) in object"</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">{</span> key <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> value <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span></code></pre>第三个参数为索引：<pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>div v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"(value, key, index) in object"</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">{</span> index <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">.</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> key <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> value <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span></code></pre></li><li><code>// todo</code></li></ol><p><strong><em>本文仅作为个人的随身读书笔记收集，没有用于任何商业盈利范畴。如若有侵犯源作者的著作权，请联系本人（立马撤文）<a href="mailto:mstarzheng@foxmail.com" target="_blank" rel="noopener">mstarzheng@foxmail.com</a></em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
