<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[经典算法篇]]></title>
    <url>%2F2018%2F11%2F11%2Falgorithm%2F</url>
    <content type="text"><![CDATA[经典算法篇计数排序​ 计数排序是一个非基于比较的排序算法，该算法于1954年由 Harold H. Seward 提出。它的优势在于在对一定范围内的整数排序时，快于任何比较排序算法。 排序思想 1.找出待排序数组最大值 2.定义一个索引最大值为待排序数组最大值的数组 3.遍历待排序数组, 将待排序数组遍历到的值作新数组索引 4.在新数组对应索引存储值原有基础上+1 代码实现 12345678910111213141516171819202122232425int main()&#123; //待排序的数组 int nums[5] = &#123;3,1,2,0,3&#125;; //用于保存排序数组 int newNums[4] = &#123;0&#125;; //计算数组的长度 int len = sizeof(nums) / sizeof(nums[0]); //遍历数组 for(int i = 0;i &lt; len; i++)&#123; //取出待排序数组当前值 int index = nums[i]; // 将待排序数组当前值作为排序数组索引 // 将用于排序数组对应索引原有值+1 newNums[index] += 1; &#125; //计算排序数组的长度 int len2 = sizeof(newNums) / sizeof(newNums[0]); //输出排序数组索引，就是排序之后结果 for(int i = 0;i &lt; len2;i++)&#123; for(int j = 0;j&lt;newNums[i];j++)&#123; printf("%i\n",i); &#125; &#125; return 0;&#125; 选择排序​ 选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素,存放到排序序列的起始位置,然后,再从剩余未排序元素中继续寻找最小元素,然后放到排序序列末尾。以此类推,直到所有元素均排序完毕。 排序思想 假设按照升序排序 1.用第0个元素和后面所有元素依次比较 2.判断第0个元素是否大于当前被比较元素, 一旦小于就交换位置 3.第0个元素和后续所有元素比较完成后, 第0个元素就是最小值 4.排除第0个元素, 用第1个元素重复1~3操作, 比较完成后第1个元素就是倒数第二小的值 以此类推, 直到当前元素没有可比较的元素, 排序完成 代码实现 123456789101112131415161718void selectSort(int numbers[],int length) &#123; // 外循环为什么要-1? // 最后一位不用比较, 也没有下一位和它比较, 否则会出现错误访问 for(int i = 0;i &lt; length;i++)&#123; for(int j = i;j &lt; length - 1;j++)&#123; if(numbers[i] &gt; numbers[j+1])&#123; // 2.一旦发现小于就交换位置 swapEle(numbers, i, j + 1); &#125; &#125; &#125;&#125;// 交换两个元素的值, i/j需要交换的索引void swapEle(int array[], int i, int j) &#123; int temp = array[i]; array[i] = array[j]; array[j] = temp;&#125; 冒泡排序​ 冒泡排序(Bubble Sort)是一种简单的排序算法。它重复 地走访过要排序的数列,一次比较两个元素,如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换,也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 排序思想 假设按照升序排序 1.从第0个元素开始, 每次都用相邻两个元素进行比较 2.一旦发现后面一个元素小于前面一个元素就交换位置 3.经过一轮比较之后最后一个元素就是最大值 4.排除最后一个元素, 以此类推, 每次比较完成之后最大值都会出现再被比较所有元素的最后 直到当前元素没有可比较的元素, 排序完成 代码实现 12345678910111213141516171819// 冒泡排序void bubbleSort(int numbers[], int length) &#123; for (int i = 0; i &lt; length; i++) &#123; // -1防止`角标越界`: 访问到了不属于自己的索引 for (int j = 0; j &lt; length - i - 1; j++) &#123; // 1.用当前元素和相邻元素比较 if (numbers[j] &gt; numbers[j + 1]) &#123; // 2.一旦发现小于就交换位置 swapEle(numbers, j, j + 1); &#125; &#125; &#125;&#125;// 交换两个元素的值, i/j需要交换的索引void swapEle(int array[], int i, int j) &#123; int temp = array[i]; array[i] = array[j]; array[j] = temp;&#125; 插入排序​ 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 排序思路: 假设按照升序排序 1.从索引为1的元素开始向前比较, 一旦前面一个元素大于自己就让前面的元素先后移动 2.直到没有可比较元素或者前面的元素小于自己的时候, 就将自己插入到当前空出来的位置 代码实现： 123456789101112131415161718192021222324252627282930//方法一：int main()&#123; //待排序的数组 int nums[4] = &#123;3,1,2,0,3&#125;; //0、计算待排序数组的长度 int len = sizeof(nums) /sizeof(nums[0]); //1、从第一元素开始依次取出所有用于比较的元素 for(int i = 1,i &lt; len;i++) &#123; //2、取出用于比较的元素 int temp = nums[i]; //3、保存前面一个元素的索引 int j = i; while(j &gt; 0)&#123; //4、判断元素是否小于前面一个元素 if(temp &lt; nums[j- 1])&#123; //小于 //5、让前面一个元素往后移动一位 nums[j] = nums[j-1]; &#125;else&#123; //大于 break; &#125; j--; &#125; //6、将元素插入到空出来的位置 nums[i] = temp; &#125; return 0;&#125; 1234567891011121314151617181920212223242526//方法二：int main()&#123; // 待排序数组 int nums[5] = &#123;3, 1, 2, 0, 3&#125;; // 0.计算待排序数组长度 int len = sizeof(nums) / sizeof(nums[0]); // 1.从第一个元素开始依次取出所有用于比较元素 for (int i = 1; i &lt; len; i++) &#123; // 2.遍历取出前面元素进行比较 for(int j = i; j &gt; 0; j--) &#123; // 3.如果前面一个元素大于当前元素,就交换位置 if(nums[j-1] &gt; nums[j])&#123; int temp = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = temp; &#125;else&#123; break; &#125; &#125; &#125; return 0 ;&#125; 希尔排序​ 1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 排序思路 1.希尔排序可以理解为插入排序的升级版, 先将待排序数组按照指定步长划分为几个小数组 2.利用插入排序对小数组进行排序, 然后将几个排序的小数组重新合并为原始数组 3.重复上述操作, 直到步长为1时,再利用插入排序排序即可 代码实现 123456789101112131415161718192021222324252627282930313233int main()&#123; // 待排序数组 int nums[5] = &#123;3, 1, 2, 0, 3&#125;; // 0.计算待排序数组长度 int len = sizeof(nums) / sizeof(nums[0]);// 2.计算步长 int gap = len / 2; do&#123; // 1.从第一个元素开始依次取出所有用于比较元素 for (int i = gap; i &lt; len; i++) &#123; // 2.遍历取出前面元素进行比较 int j = i; while((j - gap) &gt;= 0) &#123; printf("%i &gt; %i\n", nums[j - gap], nums[j]); // 3.如果前面一个元素大于当前元素,就交换位置 if(nums[j - gap] &gt; nums[j])&#123; int temp = nums[j]; nums[j] = nums[j - gap]; nums[j - gap] = temp; &#125;else&#123; break; &#125; j--; &#125; &#125; // 每个小数组排序完成, 重新计算步长 gap = gap / 2; &#125;while(gap &gt;= 1);&#125; 折半查找 基本思路 在有序表中,取中间元素作为比较对象,若给定值与中间元素的要查找的数相等,则查找成功;若给定值小于中间元素的要查找的数,则在中间元素的左半区继续查找; 若给定值大于中间元素的要查找的数,则在中间元素的右半区继续查找。不断重复上述查找过 程,直到查找成功,或所查找的区域无数据元素,查找失败 实现步骤 ①在有序表中,取中间元素作为比较对象,若给定值与中间元素的要查找的数相等,则查找成功; ②若给定值小于中间元素的要查找的数,则在中间元素的左半区继续查找; ③若给定值大于中间元素的要查找的数,则在中间元素的右半区继续查找。 ④不断重复上述查找过 程,直到查找成功,或所查找的区域无数据元素,查找失败。 代码实现 1234567891011121314151617181920212223int findKey(int values[], int length, int key) &#123; // 定义一个变量记录最小索引 int min = 0; // 定义一个变量记录最大索引 int max = length - 1; // 定义一个变量记录中间索引 int mid = (min + max) * 0.5; while (min &lt;= max) &#123; // 如果mid对应的值 大于 key, 那么max要变小 if (values[mid] &gt; key) &#123; max = mid - 1; // 如果mid对应的值 小于 key, 那么min要变 &#125;else if (values[mid] &lt; key) &#123; min = mid + 1; &#125;else &#123; return mid; &#125; // 修改完min/max之后, 重新计算mid的值 mid = (min + max) * 0.5; &#125; return -1;&#125;]]></content>
      <categories>
        <category>编程学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[老房子]]></title>
    <url>%2F2018%2F03%2F11%2F%E8%80%81%E6%88%BF%E5%AD%90%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[我问佛]]></title>
    <url>%2F2017%2F10%2F20%2F%E4%BD%9B%E6%9B%B0%2F</url>
    <content type="text"><![CDATA[我问佛为何不给世间所有女子羞花闭月的容颜？佛曰：“那只是昙花一现，用来蒙蔽世俗的眼。没有什么美，可以抵过一颗纯洁仁爱的心。我把它赐给了每一个女子，可有人让它蒙上了灰”。我问佛世间为何有那么多的遗憾？佛曰：“这是一个婆娑世界，婆娑既遗憾。没有遗憾，给你再多的幸福也不会体会快乐”。 我问佛如何让人们的心不再感到孤单？佛曰：“每一颗心生来就孤单而残缺的，多数带着这种残缺度过一生。只因与能使他圆满的另一半相遇时，不是疏忽错过，就是已失去了拥有她的资格”。 我问佛如果遇到可以爱的人，却又不怕不能把握该怎么办？佛曰：“留人间多少爱，迎浮世千重变。和有情人做快乐事，别问是劫是缘”。 我问佛如何才能如你般睿智？佛曰：“佛是过来人，人是未来佛。佛把世间万物分为十阶:佛、菩萨、生闻、圆觉、天、阿修罗、人、畜生、恶鬼、地狱。天、阿修罗、人、畜生、恶鬼、地狱，为六道众生。六道众生要经历因果轮回，从中体验痛苦，在体验痛苦的过程中。只有参透生命的真谛，才能得到永生。凤凰，涅槃”。 佛曰：“人生有八苦:生老、病死、爱别离、怨长久、求不得、放不下”。佛曰：“命有几遭，相由心生，世间万物皆是画像。心不动，万物皆不动;心不变，万物皆不变”。佛说：”坐一禅，行一禅；一花一世界，一叶一如来。春来花自清，秋至叶飘零。无穷般若，心自在;雨墨动静，题自然”。佛说：“万法皆生，皆系缘分。偶然地相遇，蓦然地回首。注定彼此的一生，只为眼神交汇的刹那。缘起既灭，缘生一空，我也曾如你般天真。佛门中说，一个人悟道有三阶段：看破、放下、自在。的确一个人必须放下，才能得到自在”。 我问佛为什么总是在我悲伤的时候下雪？佛说：“冬天就要过去，留点记忆”。 我问佛每次下雪都是我不在意的夜晚？佛说：“不经意的时候人们总是错过真正的美丽”。 我问佛那过几天还下不下雪？佛说：“不要只盯着这个季节，错过了今冬”。]]></content>
      <categories>
        <category>文字的魅力</category>
      </categories>
      <tags>
        <tag>桂林电子科技大学</tag>
        <tag>mstar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七夕情话]]></title>
    <url>%2F2017%2F08%2F28%2F%E4%B8%83%E5%A4%95%2F</url>
    <content type="text"><![CDATA[我们的故事–初雪之恋 那天初雪悄悄降临人间小小的雪花好像无数蹁跹飞舞的白色蝴蝶你牵着我的手在雪中慢慢走你说这样一直走不知不觉就白了头那夜大雪纷飞打湿了我的眼小小的手被牢牢地包在掌心所有的不安顷刻间化成白雪曾经最怕下雪的冬夜可是从那以后我才知道原来再冷的雪在爱人的怀里也能化茧成蝶 择一城终老，遇一人白首]]></content>
      <categories>
        <category>Love</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC的类]]></title>
    <url>%2F2017%2F04%2F04%2FOC-class%2F</url>
    <content type="text"><![CDATA[一、语法简介1.类在OC中，一般用2个文件来描述一个类： .h：类的声明文件，用于声明成员变量、方法。类的声明使用关键字@interface和@end。 注意：.h中的方法只是做一个声明，并不对方法进行实现。也就是说，只是说明一下方法名、方法的返回值类型、方法接收的参数类型而已，并不会编写方法内部的代码。 .m：类的实现文件，用于实现.h中声明的方法。类的实现使用关键字@implementation和@end。 2.方法1&gt; 方法的声明和实现，都必须以 + 或者 - 开头 + 表示类方法(静态方法) - 表示对象方法(动态方法) 2&gt; 在.h中声明的所有方法作用域都是public类型，不能更改 3.成员变量成员变量的常用作用域有3种： @public 全局都可以访问 @protected 只能在类内部和子类中访问 @private 只能在类内部访问 二、创建对象由于OC程序的入口点是main函数，所以在main.m文件中演示Student类的使用。先上完整代码 123456789101112#import &lt;Foundation/Foundation.h&gt;#import "Student.h"int main(int argc, const char * argv[])&#123; @autoreleasepool &#123; Student *stu = [[Student alloc] init]; [stu release]; &#125; return 0;&#125; 1.包含Student.h因为要用到Student这个类，所以在第2行包含了它的头文件 #import “Student.h” 2.创建对象1&gt; 在Java中是使用关键字new来创建对象，比如new Student()，其实这句代码做了2件事： 给对象分配存储空间 调用Student的构造方法进行初始化 2&gt; 在OC中创建对象也需要按顺序做上面所述的2件事 1)调用Student类的静态方法alloc分配存储空间 Student *stu = [Student alloc]; OC是方法调用是用中括号[ ]，方法调用者写在括号左侧，方法名写在括号右侧，中间留点空格。因此上面是调用了Student类的静态方法alloc。 上面调用的alloc方法会返回分配好内存的Student对象，在等号左边用了一个指向Student类型的指针变量stu来接收这个对象，注意stu左边的号。所有OC对象都是用指针变量来接收的，如果你不了解指针，你记住下面这点就行了：利用类名定义一个变量时，类名后面一定要带个号。 alloc方法是这样声明的： +(id)alloc; 可以看到，它的返回值类型是id，这个id代表任何指针类型，你可以暂时理解为：id可以代表任何OC对象，类似于NSObject *。 2)调用Student对象的构造方法init进行初始化 前面调用alloc方法返回的Student对象stu是不能正常使用的，因为仅仅是分配了内存，并没有进行初始化，接下来调用对象的init方法进行初始化 stu = [stu init]; 看清楚了，由于init是动态方法，所以这里使用stu变量来调用，并不是使用类名来调用。init会返回已经初始化完毕的对象，再次赋值给了stu变量。这时候的Student对象stu才能正常使用。 3)其实，我们最常见的做法是将alloc和init连起来使用： Student *stu = [[Student alloc] init]; 相信有面向对象开发经验的你一眼就能看懂了，在main.m完整代码的第7行。 三、代码解析1、如何编写类的声明 以@interface 开头，以@end结尾，然后再用class name对应的地方写上事物名称，也就是类名即可注意：类名的首字符必须大写声明一个类的目的就是为了告诉系统，我们这个类中有哪些属性和行为 OC类声明中属性只能写在@interface 和@end之间的{}中, 注意：编写oc类属性的时候，建议将所有属性的名称前面加上 _ 123456789101112@interface Iphone :NSObject&#123; //注意：默认情况下，OC对象中属性是不能直接访问的 @public //只要让类中的属性公开，以后就可以直接通过一个指向结构体的指针来操作对象中的属性 float _model; int _cpu; double _size; int _color;&#125;@end 看第1行，OC中使用关键字@interface来声明一个类，@interface后面紧跟着类名Iphone。 类名Student后面的冒号”:”表示继承，即第1行代码的意思是Iphone继承自NSObject。 第7~10行默认作用域是@protected，即可以在IPhone类内部和子类中访问 类的成员变量必须写在大括号{ }里面 2、如何编写类的实现 以@implementation开头，以@end结尾，然后在class对应的地方写上声明时声明的类的名称，必须和声明的类名一模一样 1234567@implementation Iphone//类的实现,类名必须跟声明时的类名一样- (int)_cpu &#123; // 直接返回成员变量_cpu return _cpu;&#125;@end 3、如何通过一个类来创建对象在oc中想要通过一个类来创建一个对象必须给类发送有个消息（好比c语言中调用方法一样）。而OC中是如何发送消息？ 在oc中只要想要发送消息就先写上 [类名称/对象名称 方法名称]； 发送什么消息（调用什么方法）可以创建一个对象 new 只要通过有个类调用类的new方法，也就是给类发送一个叫做new的消息后，系统内部就会做3件事情： 为IPhone类创建出来的对象分配存储空间 初始化IPhone类创建出来的对象中的属性 返回IPhone类创建出来的对象对应的地址 1234Iphone *p = [Iphone new];p-&gt;_color = 0;p-&gt;_cpu = 64;return 0; 通过一个IPhone类型的指针接收了IPhone对象的地址 如果使用给一个指针保存了某一个对象的地址，那么我们就称这个指针位之为某个类型的对应的对象 利用IPhone类型的指针保存了IPhone对象的地址，那么我们就称IPhone类型的指针p之为IPhone的对象 OC中的类其实本质就是一个结构体，所以p这个指针其实指向了一个结构体]]></content>
      <categories>
        <category>Objective-C学习整理</category>
      </categories>
      <tags>
        <tag>桂林电子科技大学</tag>
        <tag>mstar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构体]]></title>
    <url>%2F2017%2F04%2F04%2Fstruct%2F</url>
    <content type="text"><![CDATA[本文源出于—小码哥 一、什么是结构体 当一个整体由多个数据构成时，我们可以用数组来表示这个整体，但是数组有个特点：内部的每一个元素都必须是相同类型的数据。 在实际应用中，我们通常需要由不同类型的数据来构成一个整体，比如学生这个整体可以由姓名、年龄、身高等数据构成，这些数据都具有不同的类型，姓名可以是字符串类型，年龄可以是整型，身高可以是浮点型。 为此，C语言专门提供了一种构造类型来解决上述问题，这就是结构体，它允许内部的元素是不同类型的。 二、结构体的定义1.定义形式 结构体内部的元素，也就是组成成分，我们一般称为”成员”。 结构体的一般定义形式为：1234567891011struct 结构体名&#123; 类型名1 成员名1; 类型名2 成员名2; …… 类型名n 成员名n; &#125;; struct是关键字，是结构体类型的标志。 2.举例比如，我们定义一个学生12345struct Student &#123; char *name; // 姓名 int age; // 年龄 float height; // 身高&#125;; 上面定义了一个叫做Student的结构体，共有name、age、height3个成员。呵呵，看到这里是否有点面向对象的味道呢，其实这跟面向对象完全是两码事，只能说感觉有点像。 三、结构体变量的定义前面只是定义了名字为Student的结构体类型，并非定义了一个结构体变量，就像int一样，只是一种类型。 接下来定义一个结构体变量，方式有好多种。 1.先定义结构体类型，再定义变量123456 struct Student &#123; char *name; int age; &#125;;struct Student stu; 第6行定义了一个结构体变量，变量名为stu。struct和Student是连着使用的。 2.定义结构体类型的同时定义变量1234struct Student &#123; char *name; int age;&#125; stu; 结构体变量名为stu 3.直接定义结构体类型变量，省略类型名1234struct &#123; char *name; int age;&#125; stu; 结构体变量名为stu 四、结构体的注意点1.不允许对结构体本身递归定义如下做法是错误的，注意第3行1234struct Student &#123; int age; struct Student stu; &#125;; 2.结构体内可以包含别的结构体12345678910struct Date &#123; int year; int month; int day;&#125;;struct Student &#123; char *name; struct Date birthday;&#125;; 注意第9行 3.定义结构体类型，只是说明了该类型的组成情况，并没有给它分配存储空间，就像系统不为int类型本身分配空间一样。只有当定义属于结构体类型的变量时，系统才会分配存储空间给该变量 123456struct Student &#123; char *name; int age;&#125;;struct Student stu; 第1~4行并没有分配存储空间，当执行到第6行时，系统才会分配存储空间给stu变量。 4.结构体变量占用的内存空间是其成员所占内存之和，而且各成员在内存中按定义的顺序依次排列 比如下面的Student结构体：12345struct Student &#123; char *name; // 姓名 int age; // 年龄 float height; // 身高&#125;; 在16位编译器环境下，一个Student变量共占用内存：2 + 2 + 4 = 8字节。 五、结构体的初始化将各成员的初值，按顺序地放在一对大括号{}中，并用逗号分隔，一一对应赋值。 比如初始化Student结构体变量stu 123456 struct Student &#123; char *name; int age;&#125;;struct Student stu = &#123;"MJ", 27&#125;; 只能在定义变量的同时进行初始化赋值，初始化赋值和变量的定义不能分开，下面的做法是错误的：12struct Student stu;stu = &#123;"MJ", 27&#125;; 六、结构体的使用 1.一般对结构体变量的操作是以成员为单位进行的，引用的一般形式为：结构体变量名.成员名 123456789struct Student &#123; char *name; int age; &#125;; struct Student stu;// 访问stu的age成员stu.age = 27; 第9行对结构体的age成员进行了赋值。”.”称为成员运算符，它在所有运算符中优先级最高 2.如果某个成员也是结构体变量，可以连续使用成员运算符”.”访问最低一级成员 12345678910111213141516struct Date &#123; int year; int month; int day; &#125;;struct Student &#123; char *name; struct Date birthday;&#125;;struct Student stu;stu.birthday.year = 1986;stu.birthday.month = 9;stu.birthday.day = 10; 注意第14行以后的代码 3.相同类型的结构体变量之间可以进行整体赋值 1234567891011struct Student &#123; char *name; int age;&#125;; struct Student stu1 = &#123;"MJ", 27&#125;; // 将stu1直接赋值给stu2 struct Student stu2 = stu1; printf("age is %d", stu2.age); 注意第9行。输出结果为：#### age is 27 #### 七、结构体数组1.定义跟结构体变量一样，结构体数组也有3种定义方式123456789101112struct Student &#123; char *name; int age;&#125;;struct Student stu[5]; //定义1```C```Cstruct Student &#123; char *name; int age;&#125; stu[5]; //定义2 1234struct &#123; char *name; int age;&#125; stu[5]; //定义3 上面3种方式，都是定义了一个变量名为stu的结构体数组，数组元素个数是5 2.初始化1234struct &#123; char *name; int age;&#125; stu[2] = &#123; &#123;"MJ", 27&#125;, &#123;"JJ", 30&#125; &#125;; 也可以用数组下标访问每一个结构体元素，跟普通数组的用法是一样的 八、结构体作为函数参数将结构体变量作为函数参数进行传递时，其实传递的是全部成员的值，也就是将实参中成员的值一一赋值给对应的形参成员。因此，形参的改变不会影响到实参。 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt; // 定义一个结构体 struct Student &#123; int age; &#125;; void test(struct Student stu) &#123; printf("修改前的形参：%d \n", stu.age); // 修改实参中的age stu.age = 10; printf("修改后的形参：%d \n", stu.age);&#125; int main(int argc, const char * argv[]) &#123; struct Student stu = &#123;30&#125;; printf("修改前的实参：%d \n", stu.age); // 调用test函数 test(stu); printf("修改后的实参：%d \n", stu.age); return 0; &#125; 首先在第4行定义了一个结构体类型Student 在第18行定义了一个结构体变量stu，并在第22行将其作为实参传入到test函数 输出结果为：形参是改变了，但是实参一直没有变过 九、指向结构体的指针 每个结构体变量都有自己的存储空间和地址，因此指针也可以指向结构体变量 结构体指针变量的定义形式：struct 结构体名称 *指针变量名 有了指向结构体的指针，那么就有3种访问结构体成员的方式 结构体变量名.成员名 (*指针变量名).成员名 指针变量名-&gt;成员名 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt; int main(int argc, const char * argv[]) &#123; // 定义一个结构体类型 struct Student &#123; char *name; int age; &#125;; // 定义一个结构体变量 struct Student stu = &#123;"MJ", 27&#125;; // 定义一个指向结构体的指针变量 struct Student *p; // 指向结构体变量stu p = &amp;stu; /* 这时候可以用3种方式访问结构体的成员 */ // 方式1：结构体变量名.成员名 printf("name=%s, age = %d \n", stu.name, stu.age); // 方式2：(*指针变量名).成员名 printf("name=%s, age = %d \n", (*p).name, (*p).age); // 方式3：指针变量名-&gt;成员名 printf("name=%s, age = %d \n", p-&gt;name, p-&gt;age); return 0; &#125; 输出结果： 本文仅作为个人的随身读书笔记收集，没有用于任何商业盈利范畴。如若有侵犯源作者的著作权，请联系本人（立马撤文）mstarzheng@foxmail.com]]></content>
      <categories>
        <category>Objective-C学习整理</category>
      </categories>
      <tags>
        <tag>桂林电子科技大学</tag>
        <tag>mstar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac折腾手记（三）--- 百度云盘限制破解]]></title>
    <url>%2F2017%2F04%2F03%2Fbaiduyun%2F</url>
    <content type="text"><![CDATA[Mac 百度云加速下载，突破限速，大文件无压力（小白使用无压力）相信使用mac的同学们在使用百度云下载本站软件时肯定碰到过很多问题吧，尤其是大文件。最主要的是Mac端的同步盘太难用了，而且好像已经被官方抛弃了一样，很久都没有更新了。直接浏览器下载吧～限速不说，碰到大文件了还会断开，真是让人又气有无奈。 话不多说，有了这个新方法，虽然可以完全抛弃windows版的百度云了，但是要是照顾一下Windows用户的。这里分享一个windows上的百度云管家 提速破解版 密码: 2nru。 接下来直奔Mac的主题。傻瓜安装法（更适合小白同学） 1、先下载Aria2GUI dmg，解压并安装。 下载好后安装：每次下载东西的时候都需要打开这个Aria2GUI客户端 2、网盘助手 插件目前只有chrome版本在一直维护，所以，只适用于chrome浏览器，按照以下方法，安装完了以后，在百度云的下载界面会多出来一个 “导出下载”的按钮，点击这个里面的”ARIA2 RPC”，下载任务会自动在Aria2GUI客户端中开始 目前百度云插件已停止打包，使用最新版本方法如下： 下载百度云插件源代码 并解压，如图 直接将下载好的文件夹中的 chrome.crx 文件拖动到浏览器的 扩展程序界面进行安装。 安装完毕后请参考： mac折腾手记（二）— 将非官方扩展程序加入chrome的白名单 解决扩展程序失效停用的问题以上步骤都顺利完成，会在你的网页版的百度云盘中多出一个导出下载，如图所示： 接下就开始尽情的使用你的装X神器吧！！！]]></content>
      <categories>
        <category>mac笔记</category>
      </categories>
      <tags>
        <tag>桂林电子科技大学</tag>
        <tag>mstar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac折腾手记（二）]]></title>
    <url>%2F2017%2F04%2F02%2Fstudy-mac%2F</url>
    <content type="text"><![CDATA[将非官方扩展程序加入chrome的白名单 在chrome中正常使用并非来自 Chrome 网上应用店的扩展,会出现下面的情况： 小编在网上也找到了一些 英文文档来解决这类问题。 注意：该方法只适用于 通过 crx 文件安装的扩展（将crx文件拖入chrome扩展程序界面） 而还有一些类似小编一样英文不好的同学，该怎么办呢？没事你们的福利来了，跟着我一步步来走吧。。。 1、首先下载有个描述文件：Github地址下载不下来的，再提供一个网盘地址 密码：dvfx 2、打开 chrome的 扩展程序 界面，复制扩展的ID。 3、用文本编辑器打开下载好的com.google.Chrome.mobileconfig找到如图所示位置：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;&lt;plist version="1.0"&gt;&lt;dict&gt; &lt;key&gt;PayloadContent&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;PayloadContent&lt;/key&gt; &lt;dict&gt; &lt;key&gt;com.google.Chrome&lt;/key&gt; &lt;dict&gt; &lt;key&gt;Forced&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;mcx_preference_settings&lt;/key&gt; &lt;dict&gt; &lt;key&gt;ExtensionInstallWhitelist&lt;/key&gt; &lt;array&gt; &lt;string&gt;value01&lt;/string&gt; &lt;string&gt;value02&lt;/string&gt; &lt;string&gt;value03&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;key&gt;PayloadEnabled&lt;/key&gt; &lt;true/&gt; &lt;key&gt;PayloadIdentifier&lt;/key&gt; &lt;string&gt;MCXToProfile.7e2bec75-299e-44ff-b405-628007abffff.alacarte.customsettings.bdac4880-d25f-4cdd-8472-05473f005e7e&lt;/string&gt; &lt;key&gt;PayloadType&lt;/key&gt; &lt;string&gt;com.apple.ManagedClient.preferences&lt;/string&gt; &lt;key&gt;PayloadUUID&lt;/key&gt; &lt;string&gt;bdac4880-d25f-4cdd-8472-05473f005e7e&lt;/string&gt; &lt;key&gt;PayloadVersion&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;PayloadDescription&lt;/key&gt; &lt;string&gt;Included custom settings:com.google.Chrome&lt;/string&gt; &lt;key&gt;PayloadDisplayName&lt;/key&gt; &lt;string&gt;MCXToProfile: com.google.Chrome&lt;/string&gt; &lt;key&gt;PayloadIdentifier&lt;/key&gt; &lt;string&gt;com.google.Chrome&lt;/string&gt; &lt;key&gt;PayloadOrganization&lt;/key&gt; &lt;string&gt;&lt;/string&gt; &lt;key&gt;PayloadRemovalDisallowed&lt;/key&gt; &lt;true/&gt; &lt;key&gt;PayloadScope&lt;/key&gt; &lt;string&gt;System&lt;/string&gt; &lt;key&gt;PayloadType&lt;/key&gt; &lt;string&gt;Configuration&lt;/string&gt; &lt;key&gt;PayloadUUID&lt;/key&gt; &lt;string&gt;7e2bec75-299e-44ff-b405-628007abffff&lt;/string&gt; &lt;key&gt;PayloadVersion&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt;&lt;/dict&gt;&lt;/plist&gt; 这里的 19-21行 中分别对应单个扩展的ID，如果只需要一个的话，可以吧多余的两个删掉，将其中的一个标签中的值替换为第二步复制过来的 ID。编辑完后保存。如图： 4、双击打开第三步编辑好的描述文件，按照弹出的提示点击 继续-安装（输入电脑密码），安装结束后重启浏览器，就可以勾选这个扩展了，并且以后重启浏览器也不会有停用的提示了！]]></content>
      <categories>
        <category>mac笔记</category>
      </categories>
      <tags>
        <tag>桂林电子科技大学</tag>
        <tag>mstar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac折腾手记（一）---软件安装]]></title>
    <url>%2F2017%2F04%2F01%2Fmac-softer%2F</url>
    <content type="text"><![CDATA[题记：小编之前也是忠实的Windows的使用者，但是自从上手了第一个Mac后，瞬间就爱上了这台电脑，有一种上手恨晚的感觉。但是加上小编之前习惯使用Windows电脑，所以刚上手Mac甚是不习惯，比如好多安装软件都是收费的等。但是试用几天后，感觉甚是爽哉！！！下面呢，小编就带领着大家绕过装逼的这些坑。。。。。。 上来先放两个大招，对于我们在天朝一直使用免费软件的童鞋们，简直是福利呀！！！ 国内网址 可以满足大部分人的需求 国外网址 这两简直是宝藏呀（可能需要翻墙，你懂得） 但牛逼的Mac系统总会让你遇到各种问题。 有些用户下载了一些程序之后，却发现无法在MAC中安装，安装时会弹出下图所示警告框：“打不开 xxx，因为它来自身份不明的开发者”。那么该如何解决这个问题呢？ 在MAC下安装一些软件时提示”来自身份不明开发者”，其实这是MAC新系统启用了新的安全机制。默认只信任 Mac App Store 下载的软件和拥有开发者 ID 签名的应用程序。换句话说就是 MAC 系统默认只能安装靠谱渠道（有苹果审核的 Mac App Store）下载的软件或被认可的人开发的软件。 这当然是为了用户不会稀里糊涂安装流氓软件中招，但没有开发者签名的 “老实软件” 也受影响了，安装就会弹出下图所示警告框：“打不开 xxx，因为它来自身份不明的开发者”。 出现这个问题的解决方法有2种： 1、最简单的方式：按住Control后，再次点击软件图标，即可。 2、修改系统配置：系统偏好设置… -&gt; 安全性与隐私。 系统偏好设置 安全性与隐私 认证 修改为任何来源 ### 高能预警！！！！！！！！(专门为不仔细看文章的准备的。。。。。。。) ### 如果没有这个选项的话（macOS Sierra 10.12）,打开终端，执行sudo spctl –master-disable即可]]></content>
      <categories>
        <category>mac笔记</category>
      </categories>
      <tags>
        <tag>桂林电子科技大学</tag>
        <tag>mstar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[执行上下文详细图解]]></title>
    <url>%2F2017%2F03%2F29%2Fcontext%2F</url>
    <content type="text"><![CDATA[本文源出于—简书波同学 我们在JS学习初期或者面试的时候常常会遇到考核变量提升的思考题。比如先来一个简单一点的。12console.log(a); // 这里会打印出什么？var a = 20; 暂时先不管这个例子，我们先引入一个JavaScript中最基础，但同时也是最重要的一个概念 执行上下文（Execution Context）。 每次当控制器转到可执行代码的时候，就会进入一个执行上下文。执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。JavaScript中的运行环境大概包括三种情况。 全局环境：JavaScript代码运行起来会首先进入该环境 函数环境：当函数被调用执行时，会进入当前函数中执行代码 eval 因此在一个JavaScript程序中，必定会产生多个执行上下文，在我的上一篇文章中也有提到，JavaScript引擎会以堆栈的方式来处理它们，这个堆栈，我们称其为函数调用栈(call stack)。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。 当代码在执行过程中，遇到以上三种情况，都会生成一个执行上下文，放入栈中，而处于栈顶的上下文执行完毕之后，就会自动出栈。为了更加清晰的理解这个过程，根据下面的例子，结合图示给大家展示。123456789101112131415var color = 'blue';function changeColor() &#123; var anotherColor = 'red'; function swapColors() &#123; var tempColor = anotherColor; anotherColor = color; color = tempColor; &#125; swapColors();&#125;changeColor(); 我们用ECStack来表示处理执行上下文组的堆栈。我们很容易知道，第一步，首先是全局上下文入栈。 第一步：全局上下文入栈: 全局上下文入栈之后，其中的可执行代码开始执行，直到遇到了changeColor()，这一句激活函数changeColor创建它自己的执行上下文，因此第二步就是changeColor的执行上下文入栈。 第二步：changeColor的执行上下文入栈: changeColor的上下文入栈之后，控制器开始执行其中的可执行代码，遇到swapColors()之后又激活了一个执行上下文。因此第三步是swapColors的执行上下文入栈。 第三步：swapColors的执行上下文入栈: 在swapColors的可执行代码中，再没有遇到其他能生成执行上下文的情况，因此这段代码顺利执行完毕，swapColors的上下文从栈中弹出。 第四步：swapColors的执行上下文出栈: swapColors的执行上下文弹出之后，继续执行changeColor的可执行代码，也没有再遇到其他执行上下文，顺利执行完毕之后弹出。这样，ECStack中就只身下全局上下文了。 第五步：changeColor的执行上下文出栈 全局上下文在浏览器窗口关闭后出栈。 注意：函数中，遇到return能直接终止可执行代码的执行，因此会直接将当前上下文弹出栈。 上例演变过程: 详细了解了这个过程之后，我们就可以对执行上下文总结一些结论了。 单线程 同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待 全局上下文只有唯一的一个，它在浏览器关闭时出栈 函数的执行上下文的个数没有限制 每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此。 为了巩固一下执行上下文的理解，我们再来绘制一个例子的演变过程，这是一个简单的闭包例子。123456789function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999 因为f1中的函数f2在f1的可执行代码中，并没有被调用执行，因此执行f1时，f2不会创建新的上下文，而直到result执行时，才创建了一个新的。具体演变过程如下。 本文仅作为个人的随身读书笔记收集，没有用于任何商业盈利范畴。如若有侵犯源作者的著作权，请联系本人（立马撤文）mstarzheng@foxmail.com]]></content>
      <categories>
        <category>前端面试总结</category>
      </categories>
      <tags>
        <tag>桂林电子科技大学</tag>
        <tag>mstar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全方位解读this]]></title>
    <url>%2F2017%2F03%2F28%2Fthis%2F</url>
    <content type="text"><![CDATA[本文源出于—简书波同学 回顾一下执行上下文声明周期 在执行上下文的创建阶段，会分别生成变量对象，建立作用域链，确定this指向。其中变量对象与作用域链我们都已经仔细总结过了，而这里的关键，就是确定this指向。 在这里，我们需要得出一个非常重要一定要牢记于心的结论， this的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的 。因此我们可以很容易就能理解到，一个函数中的this指向，可以是非常灵活的。比如下面的例子中，同一个函数由于调用方式的不同，this指向了不一样的对象。1234567891011var a = 10;var obj = &#123; a: 20&#125;function fn () &#123; console.log(this.a);&#125;fn(); // 10fn.call(obj); // 20 除此之外， 在函数执行过程中，this一旦被确定，就不可更改了 。1234567891011var a = 10;var obj = &#123; a: 20&#125;function fn () &#123; this = obj; // 这句话试图修改this，运行后会报错 console.log(this.a);&#125;fn(); 一、全局对象中的this关于全局对象的this，我之前在总结变量对象的时候提到过，它是一个比较特殊的存在。全局环境中的this，指向它本身。因此，这也相对简单，没有那么多复杂的情况需要考虑。12345678910111213// 通过this绑定到全局对象this.a2 = 20;// 通过声明绑定到变量对象，但在全局环境中，变量对象就是它自身var a1 = 10;// 仅仅只有赋值操作，标识符会隐式绑定到全局对象a3 = 30;// 输出结果会全部符合预期console.log(a1);console.log(a2);console.log(a3); 二、函数中的this在总结函数中this指向之前，我想我们有必要通过一些奇怪的例子，来感受一下函数中this的捉摸不定。 123456// demo01var a = 20;function fn() &#123; console.log(this.a);&#125;fn(); 123456789// demo02var a = 20;function fn() &#123; function foo() &#123; console.log(this.a); &#125; foo();&#125;fn(); 123456789101112// demo03var a = 20;var obj = &#123; a: 10, c: this.a + 20, fn: function () &#123; return this.a; &#125;&#125;console.log(obj.c);console.log(obj.fn()); 这几个例子需要读者老爷们花点时间稍微感受一下，如果你暂时没想明白怎么回事，也不用着急，我们一点一点来分析。 分析之前，我们先直接了当抛出结论。 在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。 如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined 。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。 从结论中我们可以看出，想要准确确定this指向，找到函数的调用者以及区分他是否是独立调用就变得十分关键。 12345678// 为了能够准确判断，我们在函数内部使用严格模式，因为非严格模式会自动指向全局function fn() &#123; 'use strict'; console.log(this);&#125;fn(); // fn是调用者，独立调用window.fn(); // fn是调用者，被window所拥有 在上面的简单例子中，fn()作为独立调用者，按照定义的理解，它内部的this指向就为undefined。而window.fn()则因为fn被window所拥有，内部的this就指向了window对象。 那么掌握了这个规则，现在回过头去看看上面的三个例子，通过添加/去除严格模式，那么你就会发现，原来this已经变得不那么虚无缥缈，已经有迹可循了。 但是我们需要特别注意的是demo03。在demo03中，对象obj中的c属性使用this.a + 20来计算，而他的调用者obj.c并非是一个函数。因此他不适用于上面的规则，我们要对这种方式单独下一个结论。 当obj在全局声明时，无论obj.c在什么地方调用，这里的this都指向全局对象，而当obj在函数环境中声明时，这个this指向undefined，在非严格模式下，会自动转向全局对象 。可运行下面的例子查看区别。 123456789101112131415'use strict';var a = 20;function foo () &#123; var a = 1; var obj = &#123; a: 10, c: this.a + 20, fn: function () &#123; return this.a; &#125; &#125; return obj.c;&#125;console.log(foo()); // 运行会报错 实际开发中，并不推荐这样使用this； 上面多次提到的严格模式，需要大家认真对待，因为在实际开发中，现在基本已经全部采用严格模式了，而最新的ES6，也是默认支持严格模式。 再来看一些容易理解错误的例子，加深一下对调用者与是否独立运行的理解。 1234567891011var a = 20;var foo = &#123; a: 10, getA: function () &#123; return this.a; &#125;&#125;console.log(foo.getA()); // 10var test = foo.getA;console.log(test()); // 20 foo.getA()中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而test()作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。 稍微修改一下代码，大家自行理解。 123456789var a = 20;function getA() &#123; return this.a;&#125;var foo = &#123; a: 10, getA: getA&#125;console.log(foo.getA()); // 10 灵机一动，再来一个。如下例子。 123456789101112131415function foo() &#123; console.log(this.a)&#125;function active(fn) &#123; fn(); // 真实调用者，为独立调用&#125;var a = 20;var obj = &#123; a: 10, getA: foo&#125;active(obj.getA); 三、使用call，apply显示指定thisJavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有着两个方法。它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。 如下例子所示。fn并非属于对象obj的方法，但是通过call，我们将fn内部的this绑定为obj，因此就可以使用this.a访问obj的a属性了。这就是call/apply的用法。 12345678function fn() &#123; console.log(this.a);&#125;var obj = &#123; a: 20&#125;fn.call(obj); 而call与applay后面的参数，都是向将要执行的函数传递参数。其中call以一个一个的形式传递，apply以数组的形式传递。这是他们唯一的不同。 123456789function fn(num1, num2) &#123; console.log(this.a + num1 + num2);&#125;var obj = &#123; a: 20&#125;fn.call(obj, 100, 10); // 130fn.apply(obj, [20, 10]); // 50 因为call/apply的存在，这让JavaScript变得十分灵活。因此就让call/apply拥有了很多有用处的场景。简单总结几点，也欢迎大家补充。 将类数组对象转换为数组 12345678910111213141516171819function exam(a, b, c, d, e) &#123; // 先看看函数的自带属性 arguments 什么是样子的 console.log(arguments); // 使用call/apply将arguments转换为数组, 返回结果为数组，arguments自身不会改变 var arg = [].slice.call(arguments); console.log(arg);&#125;exam(2, 8, 9, 10, 3);// result:// &#123; '0': 2, '1': 8, '2': 9, '3': 10, '4': 3 &#125;// [ 2, 8, 9, 10, 3 ]//// 也常常使用该方法将DOM中的nodelist转换为数组// [].slice.call( document.getElementsByTagName('li') ); 根据自己的需要灵活修改this指向 12345678910var foo = &#123; name: 'joker', showName: function() &#123; console.log(this.name); &#125;&#125;var bar = &#123; name: 'rose'&#125;foo.showName.call(bar); 实现继承 1234567891011121314151617181920212223// 定义父级的构造函数var Person = function(name, age) &#123; this.name = name; this.age = age; this.gender = ['man', 'woman'];&#125;// 定义子类的构造函数var Student = function(name, age, high) &#123; // use call Person.call(this, name, age); this.high = high;&#125;Student.prototype.message = function() &#123; console.log('name:'+this.name+', age:'+this.age+', high:'+this.high+', gender:'+this.gender[0]+';');&#125;new Student('xiaom', 12, '150cm').message();// result// ----------// name:xiaom, age:12, high:150cm, gender:man; 简单给有面向对象基础的朋友解释一下。在Student的构造函数中，借助call方法，将父级的构造函数执行了一次，相当于将Person中的代码，在Sudent中复制了一份，其中的this指向为从Student中new出来的实例对象。call方法保证了this的指向正确，因此就相当于实现了基层。Student的构造函数等同于下。 1234567var Student = function(name, age, high) &#123; this.name = name; this.age = age; this.gender = ['man', 'woman']; // Person.call(this, name, age); 这一句话，相当于上面三句话，因此实现了继承 this.high = high;&#125; 在向其他执行上下文的传递中，确保this的指向保持不变 如下面的例子中，我们期待的是getA被obj调用时，this指向obj，但是由于匿名函数的存在导致了this指向的丢失，在这个匿名函数中this指向了全局，因此我们需要想一些办法找回正确的this指向。 12345678910var obj = &#123; a: 20, getA: function() &#123; setTimeout(function() &#123; console.log(this.a) &#125;, 1000) &#125;&#125;obj.getA(); 常规的解决办法很简单，就是使用一个变量，将this的引用保存起来。我们常常会用到这方法，但是我们也要借助上面讲到过的知识，来判断this是否在传递中被修改了，如果没有被修改，就没有必要这样使用了。 123456789var obj = &#123; a: 20, getA: function() &#123; var self = this; setTimeout(function() &#123; console.log(self.a) &#125;, 1000) &#125;&#125; 另外就是借助闭包与apply方法，封装一个bind方法。 12345678910111213141516function bind(fn, obj) &#123; return function() &#123; return fn.apply(obj, arguments); &#125;&#125;var obj = &#123; a: 20, getA: function() &#123; setTimeout(bind(function() &#123; console.log(this.a) &#125;, this), 1000) &#125;&#125;obj.getA(); 当然，也可以使用ES5中已经自带的bind方法。它与我上面封装的bind方法是一样的效果。 12345678var obj = &#123; a: 20, getA: function() &#123; setTimeout(function() &#123; console.log(this.a) &#125;.bind(this), 1000) &#125;&#125; 四、构造函数与原型方法上的this在封装对象的时候，我们几乎都会用到this，但是，只有少数人搞明白了在这个过程中的this指向，就算我们理解了原型，也不一定理解了this。所以这一部分，我认为将会为这篇文章最重要最核心的部分。理解了这里，将会对你学习JS面向对象产生巨大的帮助。 结合下面的例子，我在例子抛出几个问题大家思考一下。 1234567891011121314151617function Person(name, age) &#123; // 这里的this指向了谁? this.name = name; this.age = age;&#125;Person.prototype.getName = function() &#123; // 这里的this又指向了谁？ return this.name;&#125;// 上面的2个this，是同一个吗，他们是否指向了原型对象？var p1 = new Person('Nick', 20);p1.getName(); 我们已经知道，this，是在函数调用过程中确定，因此，搞明白new的过程中到底发生了什么就变得十分重要。 通过new操作符调用构造函数，会经历以下4个阶段。 创建一个新的对象； 将构造函数的this指向这个新对象； 指向构造函数的代码，为这个对象添加属性，方法等； 返回新对象。 因此，当new操作符调用构造函数时，this其实指向的是这个新创建的对象，最后又将新的对象返回出来，被实例对象p1接收。因此，我们可以说，这个时候，构造函数的this，指向了新的实例对象，p1。 而原型方法上的this就好理解多了，根据上边对函数中this的定义，p1.getName()中的getName为调用者，他被p1所拥有，因此getName中的this，也是指向了p1。 本文仅作为个人的随身读书笔记收集，没有用于任何商业盈利范畴。如若有侵犯源作者的著作权，请联系本人（立马撤文）mstarzheng@foxmail.com]]></content>
      <categories>
        <category>前端面试总结</category>
      </categories>
      <tags>
        <tag>桂林电子科技大学</tag>
        <tag>mstar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详细图解作用域链与闭包]]></title>
    <url>%2F2017%2F03%2F26%2Fclosure%2F</url>
    <content type="text"><![CDATA[本文源出于—简书波同学 一、作用域与作用域链在详细讲解作用域链之前，我默认你已经大概明白了JavaScript中的下面这些重要概念。这些概念将会非常有帮助。 基础数据类型与引用数据类型 内存空间 垃圾回收机制 执行上下文 变量对象与活动对象 作用域在JavaScript中，我们可以将作用域定义为一套规则,这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。 这里的标识符，指的是变量名或者函数名 JavaScript中只有全局作用域与函数作用域(因为eval我们平时开发中几乎不会用到它，这里不讨论)。 作用域与执行上下文是完全不同的两个概念。我知道很多人会混淆他们，但是一定要仔细区分。 JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。 作用域链之前我们分析的执行上下文的生命周期，如下图。 我们发现，作用域链是在执行上下文的创建阶段生成的。这个就奇怪了。上面我们刚刚说作用域在编译阶段确定规则，可是为什么作用域链却在执行阶段确定呢？ 之所以有这个疑问，是因为大家对作用域和作用域链有一个误解。我们上面说了，作用域是一套规则，那么作用域链是什么呢？是这套规则的具体实现。所以这就是作用域与作用域链的关系，相信大家都应该明白了吧。 我们知道函数在调用激活时，会开始创建对应的执行上下文，在执行上下文生成的过程中，变量对象，作用域链，以及this的值会分别被确定。之前们详细说明了变量对象，而这里，我们将详细说明作用域链。 作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。 为了帮助大家理解作用域链，我我们先结合一个例子，以及相应的图示来说明。 1234567891011121314var a = 20;function test() &#123; var b = a + 10; function innerTest() &#123; var c = 10; return b + c; &#125; return innerTest();&#125;test(); 在上面的例子中，全局，函数test，函数innerTest的执行上下文先后创建。我们设定他们的变量对象分别为VO(global)，VO(test), VO(innerTest)。而innerTest的作用域链，则同时包含了这三个变量对象，所以innerTest的执行上下文可如下表示。12345innerTestEC = &#123; VO: &#123;...&#125;, // 变量对象 scopeChain: [VO(innerTest), VO(test), VO(global)], // 作用域链 this: &#123;&#125;&#125; 是的，你没有看错，我们可以直接用一个数组来表示作用域链，数组的第一项scopeChain[0]为作用域链的最前端，而数组的最后一项，为作用域链的最末端，所有的最末端都为全局变量对象。 很多人会误解为当前作用域与上层作用域为包含关系，但其实并不是。以最前端为起点，最末端为终点的单方向通道我认为是更加贴切的形容。如图。 注意，因为变量对象在执行上下文进入执行阶段时，就变成了活动对象，这一点在上一篇文章中已经讲过，因此图中使用了AO来表示。Active Object 是的，作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符，这样就可以访问到上一层作用域中的变量了。 二、闭包对于那些有一点 JavaScript 使用经验但从未真正理解闭包概念的人来说，理解闭包可以看作是某种意义上的重生，突破闭包的瓶颈可以使你功力大增。 闭包与作用域链息息相关； 闭包是在函数执行过程中被确认。 先直截了当的抛出闭包的定义：当函数可以记住并访问所在的作用域(全局作用域除外)时，就产生了闭包，即使函数是在当前作用域之外执行。 简单来说，假设函数A在函数B的内部进行定义了，并且当函数A在执行时，访问了函数B内部的变量对象，那么B就是一个闭包 JavaScript的垃圾回收机制。JavaScript拥有自动的垃圾回收机制，关于垃圾回收机制，有一个重要的行为，那就是，当一个值，在内存中失去引用时，垃圾回收机制会根据特殊的算法找到它，并将其回收，释放内存。 而我们知道，函数的执行上下文，在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。 先来一个简单的例子。123456789101112131415var fn = null;function foo() &#123; var a = 2; function innnerFoo() &#123; console.log(a); &#125; fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn&#125;function bar() &#123; fn(); // 此处的保留的innerFoo的引用&#125;foo();bar(); // 2 在上面的例子中，foo()执行完毕之后，按照常理，其执行环境生命周期会结束，所占内存被垃圾收集器释放。但是通过fn = innerFoo，函数innerFoo的引用被保留了下来，复制给了全局变量fn。这个行为，导致了foo的变量对象，也被保留了下来。于是，函数fn在函数bar内部执行时，依然可以访问这个被保留下来的变量对象。所以此刻仍然能够访问到变量a的值。 这样，我们就可以称foo为闭包。 下图展示了闭包foo的作用域链。 我们可以在chrome浏览器的开发者工具中查看这段代码运行时产生的函数调用栈与作用域链的生成情况。如下图。 在上面的图中，红色箭头所指的正是闭包。其中Call Stack为当前的函数调用栈，Scope为当前正在被执行的函数的作用域链，Local为当前的局部变量。 所以，通过闭包，我们可以在其他的执行上下文中，访问到函数的内部变量。比如在上面的例子中，我们在函数bar的执行环境中访问到了函数foo的a变量。个人认为，从应用层面，这是闭包最重要的特性。利用这个特性，我们可以实现很多有意思的东西。 不过读者老爷们需要注意的是，虽然例子中的闭包被保存在了全局变量中，但是闭包的作用域链并不会发生任何改变。在闭包中，能访问到的变量，仍然是作用域链上能够查询到的变量。 对上面的例子稍作修改，如果我们在函数bar中声明一个变量c，并在闭包fn中试图访问该变量，运行结果会抛出错误。1234567891011121314151617var fn = null;function foo() &#123; var a = 2; function innnerFoo() &#123; console.log(c); // 在这里，试图访问函数bar中的c变量，会抛出错误 console.log(a); &#125; fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn&#125;function bar() &#123; var c = 100; fn(); // 此处的保留的innerFoo的引用&#125;foo();bar(); 闭包的应用场景接下来，我们来总结下，闭包的常用场景。 延迟函数setTimeout我们知道setTimeout的第一个参数是一个函数，第二个参数则是延迟的时间。在下面例子中， 12345function fn() &#123; console.log('this is test.')&#125;var timer = setTimeout(fn, 1000);console.log(timer); 执行上面的代码，变量timer的值，会立即输出出来，表示setTimeout这个函数本身已经执行完毕了。但是一秒钟之后，fn才会被执行。这是为什么？ 按道理来说，既然fn被作为参数传入了setTimeout中，那么fn将会被保存在setTimeout变量对象中，setTimeout执行完毕之后，它的变量对象也就不存在了。可是事实上并不是这样。至少在这一秒钟的事件里，它仍然是存在的。这正是因为闭包。 很显然，这是在函数的内部实现中，setTimeout通过特殊的方式，保留了fn的引用，让setTimeout的变量对象，并没有在其执行完毕后被垃圾收集器回收。因此setTimeout执行结束后一秒，我们任然能够执行fn函数。 柯里化在函数式编程中，利用闭包能够实现很多炫酷的功能，柯里化算是其中一种。关于柯里化，我会在以后详解函数式编程的时候仔细总结。 模块在我看来，模块是闭包最强大的一个应用场景。如果你是初学者，对于模块的了解可以暂时不用放在心上，因为理解模块需要更多的基础知识。但是如果你已经有了很多JavaScript的使用经验，在彻底了解了闭包之后，不妨借助本文介绍的作用域链与闭包的思路，重新理一理关于模块的知识。这对于我们理解各种各样的设计模式具有莫大的帮助。 123456789101112131415(function () &#123; var a = 10; var b = 20; function add(num1, num2) &#123; var num1 = !!num1 ? num1 : a; var num2 = !!num2 ? num2 : b; return num1 + num2; &#125; window.add = add;&#125;)();add(10, 20); 在上面的例子中，我使用函数自执行的方式，创建了一个模块。add是模块对外暴露的一个公共方法。而变量a，b被作为私有变量。在面向对象的开发中，我们常常需要考虑是将变量作为私有变量，还是放在构造函数中的this中，因此理解闭包，以及原型链是一个非常重要的事情。 为了验证自己有没有搞懂作用域链与闭包，这里留下一个经典的思考题，常常也会在面试中被问到。 利用闭包，修改下面的代码，让循环输出的结果依次为1， 2， 3， 4， 512345for (var i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log(i); &#125;, i*1000 );&#125; 本文仅作为个人的随身读书笔记收集，没有用于任何商业盈利范畴。如若有侵犯源作者的著作权，请联系本人（立马撤文）mstarzheng@foxmail.com]]></content>
      <categories>
        <category>前端面试总结</category>
      </categories>
      <tags>
        <tag>桂林电子科技大学</tag>
        <tag>mstar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初雪の恋]]></title>
    <url>%2F2017%2F03%2F25%2FLove%2F</url>
    <content type="text"><![CDATA[择一城终老，遇一人白首苦情痣 你说你的颈后有一颗苦情痣。你说那是因为你不愿忘记前世的爱人。你说我们不是初识，而是重新认出了彼此。你说我就是你前世的挚爱，所以，今生今世我们命中注定要在一起。前世挚爱，今世重逢。莫失莫忘，不离不弃。一切都是命中注定的，一切都是最好的安排，一切都刚刚好。今生今世，能与你再度相遇，就是我最大的幸运。 缘起 – 扬州鉴真图书馆 懵懂的恋爱 寻找自己 — 无锡大觉寺 相思之路 Perfect_World-KatieMelua &lt;iframe height=394 width=700 src=”http://c9h10n2o.qiniudn.com/disc/Movies/Perfect_World-KatieMelua-2016.mp4&quot;frameborder=0 allowfullscreen&gt;]]></content>
      <categories>
        <category>Love</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[摆脱项目命名困难的尴尬局面]]></title>
    <url>%2F2017%2F03%2F22%2F%E6%91%86%E8%84%B1%E9%A1%B9%E7%9B%AE%E5%91%BD%E5%90%8D%E5%9B%B0%E9%9A%BE%E7%9A%84%E5%B0%B4%E5%B0%AC%E5%B1%80%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[本文源出于—掘金西安小哥 1、文件夹命名 1、最好用一个单词描述 常用项目命名 oml、element、master、project、test、vue、iview 二级目录 build、static、config、src、example、base、commeon、issues、assert 三级目录 libs、models、plugins、skins、images、css、js 2、如果一个单词描述不了，名词加动词 1color-pick、button-groups、date-picker、option-group、jquery-select、jquery-swiper 3、中间用-或者_连接为了方便归类、一目了然 node_models、async-demo、array-union、array-differ、babel-each 2、文件命名 1.最好用一个单词描述一下变量名可以加css、js、html、例如index.html、index.js、index.css 常用组件命名 index、message、menu、slider（滑块）、page、progress（进度条）、tooltip（提示）、tree、upload、time、button、checkbox、dialog、cascader（三级联动） 常用文件命名 index、shopping（购物）、 share（分享）、integral（积分）、advertisement（广告）、pay（支付）、community（社区）、game、docs、bussiness 2.如果一个单词描述不了，名词加动词 1share-to-friends，share-to-community，weex-pay，alipay-pay，user-integral，game-page，docs-page等等反正就是自我想象。 3.中间用-或者_连接为了方便归类、一目了然在目前做的pc端和移动端，简单的对他们分个类： 123456789移动广告(mobile-advertisement)移动社交(mobile-social)移动电子商务(mobile-bussiness)手机游戏(mobile-game)手机电视(mobile-tv)移动电子阅读(mobile-reading)手机搜索(mobile-search)移动支付(mobile-pay)手机内容共享(mobile-share) 关于以上的项目都可以用名词+需要的动词命名，达到见词知意 3.html布局命名可以参考DIV+CSS规范命名大全 但是我觉得写得并不好，很全面。因为因为往往比较纠结的是每一个大布局中小布局的命名。1234567外套 wrap: &gt;&gt; #container头部 header: &gt;&gt; #head, #header，#nav，#sub-nav，#menu， #sub-menu，#branding主要内容 main:: &gt;&gt; bussiness-title 、bussiness-logo、bussiness-search、bussiness-search-results左侧 main-left: &gt;&gt; #side-bar, #side-bar-a, #side-bar-b右侧 main-right: &gt;&gt; #side-bar, #side-bar-a, #side-bar-b内容 content: &gt;&gt; radio-click、radio-heightlight、radio-active、input-seach-off、input-search-on底部 footer: &gt;&gt; #service, #regsiter,#partner（合作伙伴）,#joinus, #site-info 总结 12345一般头部有nav、nav-event、nav-style、nav-item、nav-link。内容：xx-title、xx-box、xx-warp、xx-item、xx-item-title、xx-item-link、xx-item-image底部：footer-time、footer-box、footer-item、footer-item-link、footer-address。总之xx-wrap，xx-box，xx-item、xx-link、xx-title、xx-total肯定会满足你80%的需求 4、js变量命名 1.基础类型和引用数据类型 12345678* 基础类型* 字符串var s_count="",* 布尔类型var b_status=false,* 数字类型var n_total=12。* 引用数据类型* 数组var ar_bar=[],* 对象var o_bar=&#123;&#125;,* 函数var f_submit=function()&#123;&#125;） 2.不要用关键字命名default、class、private 3.用可读的同义词代替保留词。 1234567891011121314/ badvar superman = &#123; class: 'alien'&#125;;// badvar superman = &#123; klass: 'alien'&#125;;// goodvar superman = &#123; type: 'alien'&#125;; 4.函数用驼峰形式（动词+名词） 1login(),logout(),expandList(),getTotal(),keySearch(),submitForm(),cancel(),goMore(),searchAll(),searchCurrent().clearContent().uploadImage().searchResult()这些都是常用事件，可以清晰知道每一项的意义。 ES5的语法规范 5.当命名的构造函数和类使用PascalCase。 1234567891011121314// badfunction user(options) &#123; this.name = options.name;&#125;var bad = new user(&#123; name: 'nope'&#125;);// goodfunction User(options) &#123; this.name = options.name;&#125;var good = new User(&#123; name: 'yup'&#125;) 6.不要使用尾随或前导下划线。 123456// badthis.__firstName__ = 'Panda';this.firstName_ = 'Panda';this._firstName = 'Panda';// goodthis.firstName = 'Panda'; 7.前缀jQuery对象变量与$。 12345678910111213141516171819202122232425262728293031323334// badvar sidebar = $('.sidebar');// goodvar $sidebar = $('.sidebar');// bad$('ul', '.sidebar').hide();// badfunction setSidebar() &#123; $('.sidebar').hide(); // ...stuff... $('.sidebar').css(&#123; 'background-color': 'pink' &#125;);&#125;// goodfunction setSidebar() &#123; var $sidebar = $('.sidebar'); $sidebar.hide(); // ...stuff... $sidebar.css(&#123; 'background-color': 'pink' &#125;);&#125;// bad$('.sidebar').find('ul').hide();// good$('.sidebar ul').hide();// good$('.sidebar &gt; ul').hide();// good$sidebar.find('ul').hide(); 5.css命名 公共的 common.css 其实和common差不多 base.css 动画 animation.css 皮肤 skin.css 文字 font.css 主题 themes.css 打印样式 print.css 颜色 color.css 6.图片命名1234第一部分是图片的逻辑归属分类第二部分是图片的表现内容第三部分是图片的内容的类型（有些图片还会有第四部分，表示图片表现的状态。）tabbar_home_icon, navigationbar_showtime_icon@2x.png，tabbar_categories_icon 本文仅作为个人的随身读书笔记收集，没有用于任何商业盈利范畴。如若有侵犯源作者的著作权，请联系本人（立马撤文）mstarzheng@foxmail.com]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>桂林电子科技大学</tag>
        <tag>mstar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针解谜]]></title>
    <url>%2F2017%2F03%2F20%2Fpointer%2F</url>
    <content type="text"><![CDATA[本文源出于—小码哥 一、什么是指针1.我们已经知道，“直接引用”是直接通过变量名来读写变量2.C语言还有一种“间接引用”的方式(以变量a为例)：_ 首先将变量a的地址存放在另一个变量中，比如存放变量b中，然后通过变量b来间接引用变量，间接读写变量a的值 _ 。这就是“间接引用”。 如果程序通过”间接引用”的方式来修改a的值，可以这样做：先根据变量名b 获取 变量b的地址ffc2，取出变量b中存储的内容ffc1，也就是变量a的地址，再根据变量a的地址ffc1找到a的存储空间，然后修改里面的数据。 3.总结一句：用来存放变量地址的变量，就称为”指针变量”。在上面的情况下，变量b就是个”指针变量”，我们可以说指针变量b指向变量a。 二、指针定义一般形式： 类名标识符 * 指针变量名；123int *p;float *q; “*“是一个说明符，用来说明这个变量是个指针变量，是不能省略的，但它不属于变量名的一部分前面的类型标识符表示指针变量所指向的变量的类型，而且只能指向这种类型的变量 三、指针的初始化1.先定义后初始化12345678// 定义int类型的变量aint a = 10;// 定义一个指针变量pint *p;// 将变量a的地址赋值给指针变量p，所以指针变量p指向变量ap = &amp;a; 注意第8行，赋值给p的是变量a的地址&amp;a 2.在定义的同时初始化123456// 定义int类型的变量aint a = 10;// 定义一个指针变量p// 并将变量a的地址赋值给指针变量p，所以指针变量p指向变量aint *p = &amp;a; 3.初始化的注意指针变量是用来存放变量地址的，不要给它随意赋值一个常数。下面的写法是错误的12int *p;p = 200; // 这是错误的 四、指针运算符1.给指针指向的变量赋值12345678910char a = 10;printf("修改前，a的值：%d\n", a);// 指针变量p指向变量achar *p = &amp;a;// 通过指针变量p间接修改变量a的值*p = 9;printf("修改后，a的值：%d", a); 当程序刚执行完第5行代码时，内存中大概的分布情况是这样的 a值是10，p值就是变量a的地址ffc3。 注意下第5、第8行，都有个“*”，它们的含义是不一样的： 第5行的“*”只是用来说明p是个指针变量 第8行的“星号”是一个指针运算符，这里的* p代表根据p值ffc3这个地址访问对应的存储空间，也就是变量a的存储空间，然后将右边的数值9写入到这个存储空间，相当于 a = 9;，于是内存中就变成这样了 输出结果为： 可以发现，我们通过变量p间接修改了变量a的值。 2.取出指针所指向变量的值指针运算符除了可以赋值之外，还可以用于取值1234567 char a = 10; char *p; p = &amp;a;char value = *p; printf("取出a的值：%d", value); 输出结果：第6行中的*p的意思是：根据p值(即变量a的地址)访问对应的存储空间，并取出存储的内容(即取出变量a的值)，赋值给value 3.使用注意在指针变量没有指向确定地址之前，不要对它所指的内容赋值。下面的写法是错误的12int *p;*p = 10; //这是错误的 应该在指针变量指向一个确定的变量后再进行赋值。下面的写法才是正确的 123456789// 定义2个int型变量int a = 6, b;// 定义一个指向变量b的指针变量pint *p;p = &amp;b;// 将a的值赋值给变量b*p = a; 五、指针的用途举例1.例子1前面我们通过指针变量p间接访问了变量a，在有些人看来，觉得指针变量好傻B，直接用变量名a访问变量a不就好了么，干嘛搞这么麻烦。别着急，接下来举个例子，让大家看看指针还能做什么事情。 现在有个要求：写一个函数swap，接收2个整型参数，功能是互换两个实参的值。 1&gt; 如果没学过指针，你可能会这样写 123456789101112131415161718192021222324void swap(char v1, char v2) &#123; printf("更换前：v1=%d, v2=%d\n", v1, v2); // 定义一个中间变量 char temp; // 交换v1和v2的值 temp = v1; v1 = v2; v2 = temp; printf("更换后：v1=%d, v2=%d\n", v1, v2);&#125;int main()&#123; char a = 10, b = 9; printf("更换前：a=%d, b=%d\n", a, b); swap(a, b); printf("更换后：a=%d, b=%d", a, b); return 0;&#125; 输出结果：虽然v1和v2的值被交换了，但是变量a和b的值根本就没有换过来。因为基本数据类型作为函数实参时，只是纯粹地将值传递给形参，形参的改变并不影响实参。我们可以简要分析一下这个过程： 在第20行中，将变量a、b的值分别传递给了swap函数的两个形参v1、v2 在第8行中，将v1的值赋值给了temp 在第9行中，将v2的值赋值给了v1 在第10行中，将temp的值赋值给了v2 就这样，v1和v2的值被交换了，但是a和b的值一直都没有改变 2&gt; 如果学了指针，就应该这样写123456789101112131415161718192021222324void swap(char *v1, char *v2) &#123; // 中间变量 char temp; // 取出v1指向的变量的值 temp = *v1; // 取出v2指向的变量的值，然后赋值给v1指向的变量 *v1 = *v2; // 赋值给v2指向的变量 *v2 = temp; &#125; int main() &#123; char a = 10, b = 9; printf("更换前：a=%d, b=%d\n", a, b); swap(&amp;a, &amp;b); printf("更换后：a=%d, b=%d", a, b); return 0; &#125; 先看看输出结果： 变量a和b的值终于换过来了。 解释一下：(在16位编译器环境下，一个指针变量占用2个字节) 先注意第20行，传递是变量的地址。因此swap函数的形参v1指向了变量a，v2指向了变量b 第6行代码是取出v1指向的变量的值，也就是变量a的值：10，然后赋值给变量temp 第9行代码是取出v2指向的变量(变量b)的值，然后赋值给v1指向的变量(变量a) 第12行代码是将temp变量的值赋值给v2指向的变量(变量b) 相信你已经感受到指针的强大了，如果没有指针，在一个函数的内部根本改变不了外部的实参。 2.例子2接下来再举一个指针的实用例子。默认情况下，一个函数只能有一个返回值，有了指针，我们可以实现函数有”多返回值”。 现在有个要求：写一个函数sumAndMinus，可以同时计算2个整型的和与差，函数执行完毕后，返回和与差(注意了，这里要返回2个值)123456789101112131415161718192021222324252627// 计算2个整型的和与差int sumAndMinus(int v1, int v2, int *minus) &#123; // 计算差，并赋值给指针指向的变量 *minus = v1 - v2; // 计算和，并返回和 return v1 + v2;&#125;int main()&#123; // 定义2个int型变量 int a = 6, b = 2; // 定义2个变量来分别接收和与差 int sum, minus; // 调用函数 sum = sumAndMinus(a, b, &amp;minus); // 打印和 printf("%d+%d=%d\n", a, b, sum); // 打印差 printf("%d-%d=%d\n", a, b, minus); return 0;&#125; 输出结果：和与差都由同一个函数计算并返回出来。和是函数的直接返回值，差是通过函数的第3个指针参数间接返回。因此有了指针，我们可以让函数有”无限个”返回值。 六、关于指针的疑问刚学完指针，都可能有一大堆的疑惑，这里我列出几个常见的疑惑吧。 1.一个指针变量占用多少个字节的内存空间？占用的空间是否会跟随所指向变量的类型而改变？ 在同一种编译器环境下，一个指针变量所占用的内存空间是固定的。比如，在16位编译器环境下，任何一个指针变量都只占用2个字节，并不会随所指向变量的类型而改变。 2.既然每个指针变量所占用的内存空间是一样的，而且存储的都是地址，为何指针变量还要分类型？而且只能指向一种类型的变量？比如指向int类型的指针、指向char类型的指针。 其实，我觉得这个问题跟”数组为什么要分类型”是一样的。 看下面的代码，利用指针p读取变量c的值12345678int i = 2;char c = 1; // 定义一个指向char类型的指针 char *p = &amp;c; // 取出 printf("%d", *p); 这个输出结果应该难不倒大家： 1 ，是可以成功读取的。 如果我改一下第5行的代码，用一个本应该指向int类型变量的指针p，指向char类型的变量c int *p = &c; 我们再来看一下输出： 513 ，c的原值是1，现在取出来却是513，怎么回事呢？这个要根据内存来分析 根据变量的定义顺序，这些变量在内存中大致如下图排布： 其中，指针变量p和int类型变量i各占2个字节，char类型的c占一个字节，p指向c，因此p值就是c的地址 1&gt; 最初的时候，我们用char p指向变量c。当利用p来获取变量c的值时，由于指针p知道变量c是char类型的，所以会从ffc3这个地址开始读取1个字节的数据：0000 0001，转为10进制就是1 2&gt; 后来，我们用int p指向变量c。当利用p获取变量c的值时，由于指针p认为变量c是int类型的，所以会从ffc3这个地址开始读取2个字节的数据：0000 0010 0000 0001，转为10进制就是513 可见，给指针分类是多么重要的一件事，而且一种指针最好只指向一种类型的变量，那是最安全的。 本文仅作为个人的随身读书笔记收集，没有用于任何商业盈利范畴。如若有侵犯源作者的著作权，请联系本人（立马撤文）mstarzheng@foxmail.com]]></content>
      <categories>
        <category>Objective-C学习整理</category>
      </categories>
      <tags>
        <tag>桂林电子科技大学</tag>
        <tag>mstar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试集结号---HTML]]></title>
    <url>%2F2017%2F03%2F16%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B-HTML%2F</url>
    <content type="text"><![CDATA[相关知识 web标准、web语义、浏览器内核、兼容性、html5… 常见面试问题&amp;答案 1、Doctype作用？严格模式与混杂模式如何区分？它们有何意义? 123&lt;!DOCTYPE&gt;声明位于HTML文档中的第一行，处于&lt;html&gt;标签之前，用于告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。如果HTML文档包含形式完整的DOCTYPE，那么他一般以标准模式呈现。对于HTML4.01文档，包含严格DTD的DOCTYPE常常导致页面已标准模式呈现。DOCTYPE不存在或者格式不正确会导致文档已混杂模式呈现。 2、请描述一个网页从开始请求道最终显示的完整过程 一个网页从请求到最终显示的完整过程一般可以分为如下7个步骤： 1234567在浏览器中输入网址；发送至DNS服务器并获得域名对应的WEB服务器IP地址；与WEB服务器建立TCP连接；浏览器向WEB服务器的IP地址发送相应的HTTP请求；WEB服务器响应请求并返回指定URL的数据，或错误信息，如果设定重定向，则重定向到新的URL地址；浏览器下载数据后解析HTML源文件，解析的过程中实现对页面的排版，解析完成后在浏览器中显示基础页面；分析页面中的超链接并显示在当前页面，重复以上过程直至无超链接需要发送，完成全部数据显示。 3、HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;12HTML5不基于SGML，因此不需要对DTD进行引用，但是需要DOCTYPE来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；HTML4.01基于SGML，所以需要对DTD进行引用，才能让浏览器知道该文档所使用的文档类型。 4、行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？123456789 ***行内元素***：a - 锚点，em - 强调，strong - 粗体强调，span - 定义文本内区块，i - 斜体,img - 图片,b - 粗体，label - 表格标签，select - 项目选择，textarea - 多行文本输入框，sub - 下标，sup - 上标，q - 短引用； ***块元素***：div - 常用块级，dl - 定义列表，dt，dd，ul- 非排序列表，li，ol-排序表单，p-段落，h1，h2，h3，h4，h5-标题，table-表格，fieldset - form控制组，form - 表单， ***空元素***：br-换行，hr-水平分割线； 5、介绍一下你对浏览器内核的理解1浏览器最重要或者说核心的部分是“Rendering Engine”，可大概译为“渲染引擎”，不过我们一般习惯将之称为“浏览器内核”。负责对网页语法的解释（如标准通用标记语言下的一个应用HTML、JavaScript）并渲染（显示）网页。 所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因。 6、常见的浏览器内核有哪些12345Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等。Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;]Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）]EdgeHTML内核：Microsoft Edge。 [此内核其实是从MSHTML fork而来，删掉了几乎所有的IE私有特性] 7、html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 1234567891011121314151617181920***新增了以下的几大类元素***内容元素，article、footer、header、nav、section。表单控件，calendar、date、time、email、url、search。控件元素，webworker, websockt, Geolocation。***移出的元素有下列这些****显现层元素：basefont，big，center，font, s，strike，tt，u。性能较差元素：frame，frameset，noframes。HTML5已形成了最终的标准，概括来讲，它主要是关于图像，位置，存储，多任务等功能的增加。新增的元素有绘画 canvas ，用于媒介回放的 video 和 audio 元素，本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失，而sessionStorage的数据在浏览器关闭后自动删除，此外，还新增了以下的几大类元素。内容元素，article、footer、header、nav、section。表单控件，calendar、date、time、email、url、search。控件元素，webworker, websockt, Geolocation。***移出的元素有下列这些***显现层元素：basefont，big，center，font, s，strike，tt，u。性能较差元素：frame，frameset，noframes。***新的技术***canvas,svg,webworker, websocket, Geolocation...... 8、简述一下你对HTML语义化的理解1234HTML语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；即使在没有样式CSS的情况下也能以一种文档格式显示，并且是容易阅读的；搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，有利于SEO；使阅读源代码的人更容易将网站分块，便于阅读、维护和理解。 9、HTML5的离线存储怎么使用？能否解释一下工作原理 在用户没有连接英特网时，可以正常访问站点和应用；在用户连接英特网时，更新用户机器上的缓存文件。原理：HTML5的离线存储是基于一个新建的 .appcache 文件的缓存机制（并非存储技术），通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储下来。之后当网络处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。使用方法 123456789101112在页面头部像下面一样加入一个 manifest 的属性；在 cache.manifest 文件里编写离线存储资源； CACHE MANIFEST #v0.11 CACHE： js/app.js css/style.css NETWORK: resource/logo.png FALLBACK： / /offline.html在离线状态时，操作 window.applicationCache 进行需求实现； 10、浏览器是怎么对HTML5的离线储存资源进行管理和加载的12在线情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。离线情况下，浏览器就直接使用离线存储的资源。 11、请描述一下 cookies，sessionStorage 和 localStorage 的区别1234567Web Storage有两种形式：LocalStorage（本地存储）和sessionStorage（会话存储）。这两种方式都允许开发者使用js设置的键值对进行操作，在在重新加载不同的页面的时候读出它们。这一点与cookie类似。&gt;&gt; 与cookie不同的是：Web Storage数据完全存储在客户端，不需要通过浏览器的请求将数据传给服务器，因此x相比cookie来说能够存储更多的数据，大概5M左右。&gt;&gt; LocalStorage和sessionStorage功能上是一样的，但是存储持久时间不一样。LocalStorage：浏览器关闭了数据仍然可以保存下来，并可用于所有同源（相同的域名、协议和端口）窗口（或标签页）；sessionStorage：数据存储在窗口对象中，窗口关闭后对应的窗口对象消失，存储的数据也会丢失。注意：sessionStorage 都可以用localStorage 来代替，但需要记住的是，在窗口或者标签页关闭时，使用sessionStorage 存储的数据会丢失。&gt;&gt; 使用 local storage和session storage主要通过在js中操作这两个对象来实现，分别为window.localStorage和window.sessionStorage. 这两个对象均是Storage类的两个实例，自然也具有Storage类的属性和方法。 12、iframe 有哪些缺点1234iframe会阻塞主页面的Onload事件；搜索引擎的检索程序无法解读这种页面，不利于SEO；iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好通过JavaScript动态给iframe添加src属性值，这样可以绕开以上两个问题。 13、Label的作用是什么？如何使用1234label标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。&lt;label for="Name"&gt;Number:&lt;/label&gt;&lt;input type="text" name="Name" id="Name" /&gt;&lt;label&gt;Date:&lt;input type="text" name="B" /&gt;&lt;/label&gt; 14、HTML5的form如何关闭自动完成功能 给不想要提示的 form 或下面某个 input 设置为 autocomplete = off。 15、如何实现浏览器内多个标签页之间的通信？（阿里） 调用 localStorage、cookies 等本地存储方式 16、webSocket 如何兼容低浏览器？（阿里） Adobe Flash SocketActiveX HTMLFile（IE）基于 multipart 编码发送 XHR基于长轮询的 XHR 17、页面可见性（Page Visibility） API可以有哪些用途 在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放。 18、如何在页面上实现一个圆形的可点击区域？123map + area 或者 svgborder-radius纯js实现，需要求一个点在不在圆上的简单算法、获取鼠标坐标等等 19、实现 不使用 border 画出 1px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果1&lt;div style="height:1px;overflow:hidden;background:#ccc"&gt;&lt;/div&gt; 20、网页验证码是干什么用的？是为了解决什么安全问题 可以防止：恶意破解密码、刷票、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试，实际上用验证码是现在很多网站通行的方式，我们利用比较简易的方式实现了这个功能。这个问题可以由计算机生成并评判，但是必须只有人类才能解答。由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。 本文仅作为个人的随身读书笔记收集，没有用于任何商业盈利范畴。如若有侵犯源作者的著作权，请联系本人（立马撤文）mstarzheng@foxmail.com]]></content>
      <categories>
        <category>前端面试总结</category>
      </categories>
      <tags>
        <tag>mstar</tag>
        <tag>南京邮电大学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[话说汉朝四百年的外戚干政史]]></title>
    <url>%2F2017%2F03%2F08%2F%E8%AF%9D%E8%AF%B4%E6%B1%89%E6%9C%9D%E5%9B%9B%E7%99%BE%E5%B9%B4%E7%9A%84%E5%A4%96%E6%88%9A%E5%B9%B2%E6%94%BF%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[简介 一段时间以来，韩国总统“闺蜜门”的新闻印刷爆微信朋友圈，爆闹得沸沸扬扬。其实朴瑾惠的秘书有大几百号人，这些都是帮她出谋划策的家臣们。那么为什么她还要问政于闺蜜，而“闺蜜干政”事件又怎么会触怒韩国民众呢？对于一位总统问政于闺蜜被人深扒为政治事件这一定有很深的背景，我们今天就姑且不去探讨。其实在朝鲜古代历史和中国封建社会历朝历代家臣干政的事是经常发生的。那么我们今天去扒一扒有着四百多年历史的汉朝皇帝的那些家臣–外戚是干政的历史吧。 一、西汉外戚干政概说 外戚是指皇帝的母亲和妻子家族，作为与皇室有关联的特殊政治力量，历代在中国政治舞台上扮演者特殊的角色。这种角色是由其特殊身份决定的：其与皇权最为接近，但有距离皇权最远。正是因为皇权的存在使得外戚在历代的政治斗争中往往成为皇权的牺牲品。历代王朝在外戚的任用中也是慎之又慎，以防止皇权旁落。防止外戚对于皇权的窥视成为历代王朝政治斗争的主要任务之一，历代王朝为防止外戚篡权基本上采取不让外戚干政的基本政策。但汉朝却是个例外。 两汉王朝四百多年的历史中外戚作为特殊的政治力量一直活跃在政治舞台之上，并且一度篡权皇权，建立了外戚政权。这可以说在中国历史上是外戚专权的顶峰。纵观汉朝四百多年的历史，外戚作为特殊的政治力量一直处于汉王朝政权的中心位置，成为掌握实权的政治力量。而且大部分时候成为与皇权并驾齐驱的政治力量，这种政治格局一直持续到东汉末年。可以说外戚在汉朝四百年历史中扮演的角色是以后历代王朝中所不能比拟的，这成为汉朝统治的最大特色。 西汉朝任用外戚作为权利中心决策者始于汉高祖刘邦，据吕思勉先生之说这是因为汉朝去古代不远，是前代时期的遗风。在汉代政治舞台上存在三股政治势力：皇帝、外戚、功臣。这三股势力中皇帝处于中心地位，皇帝为了维持自己的皇权必须要求有政治势力来支持自己的统治。对于功臣这在其获取江山并在保持江山的稳定中起着至关重要的作用，但功臣就亲属关系上必定属于外人，与皇权本身就存在着矛盾。并且功臣在汉朝政治舞台上本身存在着真实实力，这是对皇权的一种威胁。但外戚不同。外戚是皇帝的姻亲，与皇帝有着血缘的关系，正是这种特殊的关系使得汉朝的皇帝在人事权的任用上偏重于外戚。这种任用外戚似乎成了汉朝的惯例，正如《后汉书·皇后纪》记载：汉兴，舅氏之封侯，犹皇子之为王也。可见汉朝对于外戚的重视。 西汉朝任用外戚主政也始于汉高祖刘邦之时，《史记·高祖本纪》记载：戚姬幸，常从上之关东，日夜啼泣，欲立其子代太子。吕后年长，常留守，希见上，益疏。汉高祖刘邦在外征伐之时，吕后因年长常常留守后方，主持政务。这似乎成了外戚参政的开端。吕后专权开启了外戚专权的先例。吕后掌握汉朝政权后，为了维持自己的统治任用吕氏家族的人掌握汉朝中央的军政大权。吕氏一族掌握汉室政权，开启了外戚专权的开端，但在汉初朝中的政策方针很多出于吕后之手，诛杀韩信、诛杀彭越，都出于吕后之手。吕后在汉初政权的巩固之中却是起了重要的作用。正是由于吕后才使得汉王朝继续着休养生息，有利于发展封建社会的经济。 文帝之时，由于其是被功臣拥立继位，并且其母家薄氏势力又弱，因此在外戚重用方面主要是其皇后窦姓一族。我们要说文帝之所以能继承皇位在很大关系上也得益于其母家，因其母家势力弱小，因此在汉初经历了吕后之事后大臣鉴于历史教训，拥立了母家实力弱小的代王刘恒。可见此时功臣与外戚势力在政治斗争中的激烈程度，双方都希望能掌控实权。 汉景帝时期自然重用其母家窦姓一族，在汉景帝一生中其母窦太后起着重要作用，窦姓一族构成了汉朝中央统治力量的核心，但此时外戚势力远远小于皇权，但在大臣的选用策略上是倾向于外戚的。 汉武帝初期重用的是自己母家一族，其母亲异性弟弟田蚡一度成为丞相，掌控大权。这时形成了外戚与皇权争夺权力的斗争，在汉武帝时期为加强皇权设置了内朝，这就形成了与丞相为首的官僚集团相对持，使得权力最终落入了皇帝手中。在田蚡之后汉武帝甚至将外戚卫青封为大将军，霍去病封也为将军，这与当时汉武帝武功之治是分不开的，可以说卫氏一族在汉武帝时期达到鼎盛，这是汉武帝重用外戚的结果。 汉昭帝、汉宣帝、汉元帝等也都在重臣的选择上无疑也倾向于外戚，外戚组成了汉朝统治集团的核心力量。正是这种外戚当权的政策使得在汉成帝时期可谓达到了登峰造极之势，正是从汉成帝时期开始，外戚逐步掌握了汉朝中央大权，最终酿王莽篡汉的惨祸。 汉成帝继位继封外戚王凤为大司马领尚书事，使得外戚兼有内外朝之职事，权力可谓盛。《汉书·元后传》记载：元帝崩，太子立，是为孝成帝。尊皇后为皇太后，以凤为大司马大将军领尚书事，益封五千户。王氏之兴自凤始。又封太后同母弟崇为安成侯，食邑万户。凤庶弟谭等皆赐爵关内侯，食邑。然而这仅仅只是开头，正是汉成帝的作用，使得外戚势力如日中天，达到前汉前所未有的水平。 汉成帝河平二年，外戚势力更是更是跃升一层，从此外戚势力更加强大，使得外戚成为权力的真正中心。《元后传》记载：成帝河平二年，上悉封舅谭为平阿侯，商成都侯，立红阳侯，根曲阳侯，逢时高平侯。五人同日封，故世谓之「五侯」。自此王氏子弟皆卿、大夫、侍中、诸曹，分据势官满朝廷。至此，外戚势力直逼皇权。汉成帝死后无嗣，定陶王刘欣继位，是为汉哀帝，汉哀帝是一位颇有作为君主，在其即位之初即刻罢归王氏一族，但其有人用自己祖母、母亲一族是为丁、傅家族。但此时外戚势力不能与王氏同日而语。哀帝有个致命的弱点就是宠幸男宠，甚至打算将汉室江山让与这位男宠董贤，在其继位不就也便死去，其死后无嗣，此时正是这个契机让王氏一族又重掌朝政大权，并最终使得汉王朝走向灭亡。 汉哀帝死后，太皇太后王氏立刻将皇帝的玉玺收入自己的手中，并立刻让王氏子孙组成新的统治中心。《元后传》记载： 明年，哀帝崩，无子，太皇太后以莽为大司马，与共征立中山王奉哀帝后，是为平帝。帝年九岁，当年被疾，太后临朝，委政于莽。从此，开始了王莽的执政道路，正是王莽使得西汉朝最终覆灭。 二、东汉西汉外戚干政概说 东汉王朝初期鉴于前汉王莽的教训，在初期严禁外戚参与中央政权，汉明帝的皇后马皇后因其父是外戚之家不得利于凌云台。这正是对外戚的限制。《后汉书·皇后纪》记载：及帝崩，肃宗即位，尊后曰皇太后。诸贵人当徙居南宫，太后感析别之怀，各赐王赤绶，加安车驷马，白越三千端，杂帛二千匹，黄金十斤。自撰《显宗起居注》，削去兄防参医药事。帝请曰：”黄门舅旦夕供养且一年，既无褒异，又不录勤劳，无乃过乎！”太后曰：”吾不欲令后世闻先帝数亲后宫之家，故不著也。”可见，东汉初统治者对于外戚的防范还是很严的。 东汉外戚干政开始于汉和帝时期。外戚又进入政治权利之中，这是与后汉此时特殊的政治形态相适应的。自和帝开始汉朝的继位之君大多年幼，这时作为皇帝的母亲–太后做到到历史舞台的前端。汉和帝死后，东汉和熹皇后即邓太后还形成临朝执政16年的局面。根据历史记载，邓太后与班固之妹班昭是闺蜜，在邓太后执政前后，多问政于这位闺蜜。邓太后执政颇有政声，应该与班昭的辅佐分不开。要说起来还真的成就一段闺蜜干政的历史佳话呢。太后执政必然依靠自己的母亲家族，最后就形成了以太后为首的外戚集团。这就形成了外戚集团与皇帝集团在权力上的激烈的斗争。在东汉统治者为了平衡政治力量，在外戚与皇帝的斗争中又出现了一个新的政治势力宦官集团。自和帝开始直到灵帝皇帝、宦官与外戚的斗争交织在一起，甚至形成一种互掐局面。东汉王朝外戚在实力上超过西汉，并且皇帝的废立也由外戚掌握。外戚势力之所以如此强大主要原因在于继位之君年龄弱小，不能亲理朝政，使得朝政大权落入其母后之手，作为妇女其只能依靠自己的母家维持其统治，这就为外戚势力的发展提供了温床。使得外戚的势力在相当长的时期内得到扩张。 纵观东汉外戚专权的历史，其较西汉势力更是有过之而无不及。由于继位之君年龄的幼小，外戚才能作为特殊血缘关系集团登上政治舞台。在皇帝长成后外戚在政治舞台上已经经营多年，势力远远超过皇权，外朝大臣几乎全为外戚的党羽，皇权往往被架空。皇帝此时在巩固皇权的道路上只有依靠宦官这个集团，最终形成了宦官集团，不过终汉代宦官集团是从属皇帝的，其实力远远在皇权之下，自始至终只是皇权的附属物。 三、两汉外戚干政的历史影响 外戚贯穿于汉朝四百年历史，一直在汉朝政治舞台上扮演重要的角色，但前汉后汉的外戚在任用上却有着质的不同。 西汉在外戚任用上是皇帝根据当时政治平衡而采取的政策，是任用自己血缘亲来加强皇权，外戚在此时只是加强皇权的工具，直到汉平帝时期为止。东汉则是继位之君大多年幼，皇帝母亲执政，只能依靠外戚，这不是皇帝选择的结果，在外戚势力强大之时皇帝的废立也掌握在外戚手中，使得外戚的势力与皇帝形成对抗，并最终皇帝在宦官集团的帮助下将外戚集团将外戚势力铲除。 外戚集团作为汉朝历史上的特殊政治集团，在汉朝历史舞台上扮演着重要角色。汉朝重用外戚是此后任何王朝所不能比拟的，这与汉王朝建立之时距离秦代不远，宗法血缘思想依然浓厚。正是宗法血缘思想影响统治者才重用与自己有血缘关系的外戚，但正是外戚也使得前汉、后汉陷入了统治危机中，造成一次次内乱，消弱了自身统治力量。尤其是东汉还出现外戚集团和宦官集团互掐的政治局面。使得政治尤为黑暗，最终促成了汉末农民起义，但总的来说这些的出现是由于外戚集团的促使而成的。外戚集团在汉王朝的巩固上虽然起了重要作用，但最后也成为汉王朝的掘墓者。 四、两汉王朝外戚干政的历史教训 封建君主专制制度是高度集权的，其负面影响有两个就是政治腐败和决策失误。而决策失误又往往和大权旁落相关。大权旁落时往往又是和外戚干政与宦官专权相连。在中国封建两千多的历史长河中，外戚和宦官交替干政不绝于史书。外戚和宦官这两股政治力量的兴衰都是皇权的副产品。外戚干政几乎贯穿于汉王朝四百多年，外戚集团成为政治舞台上不能忽视的力量。汉朝四百年重用外戚是以后历代王朝所不能比拟的，所造成的政治黑暗也是最惨重的。正是汉朝的惨痛教训才使得以后王朝以此为戒，注意控制外戚势力，这或许是外戚在汉朝四百年历史舞台里留给后世的深刻经验教训吧。 本文仅作为个人的随身读书笔记收集，没有用于任何商业盈利范畴。如若有侵犯源作者的著作权，请联系本人（立马撤文）mstarzheng@foxmail.com]]></content>
      <categories>
        <category>文字的魅力</category>
      </categories>
      <tags>
        <tag>福建省建阳第一中学</tag>
        <tag>吴文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue学习笔记]]></title>
    <url>%2F2016%2F11%2F29%2Fvue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言最近由于项目需要，重新研究起了vue，说到vue，在几个月前就间歇性或多或少有过接触，因为当时用惯了react，有点不习惯vue的模式放弃了，在vue2.0出来后，以及weex的推动，vue的关注度又有了很大的提高，加之项目比较迫切，本来是几个月就该完工的项目，因为种种原因，加上研究生学习繁忙，以后react版本的代码过于复杂，导致后期维护麻烦，遂准备使用vue和apollo进行项目的重写，这篇文章是vue的学习记录 基础上下文问题注意，不要在实例属性或者回调函数中（如 vm.$watch(&#39;a&#39;, newVal =&gt; this.myMethod())）使用 箭头函数。因为箭头函数绑定父上下文，所以 this 不会像预想的一样是 Vue 实例，而是 this.myMethod 未被定义。 缩写v-bind:1234&lt;!-- 完整语法 --&gt;&lt;a v-bind:href="url"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href="url"&gt;&lt;/a&gt; v-on:1234&lt;!-- 完整语法 --&gt;&lt;a v-on:click="doSomething"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click="doSomething"&gt;&lt;/a&gt; 计算属性在模板中使用绑定表达式很方便，但是只能用于简单的操作，在模板中放入太多的逻辑会让模板变得难以维护，所以对于任何复杂逻辑，都应该使用 计算属性 计算缓存vsMethods不经过计算属性，我们可以在 method 中定义一个相同的函数来替代它。然而 不同的是计算属性是基于它的依赖缓存。 计算属性只有在它的相关依赖发生改变时才会重新取值。 class与style绑定 对象语法 1234&lt;div v-bind:class="&#123; active: isActive &#125;"&gt;&lt;/div&gt;data: &#123; isActive: true,&#125; 数组语法 12345&lt;div v-bind:class="[activeClass, errorClass]"&gt;data: &#123; activeClass: 'active', errorClass: 'text-danger'&#125; 条件渲染 v-if是一个指令，需要将他添加到一个元素上，如果需要切换多个元素可以在多个元素的外面包裹一个 &lt;template&gt;元素，并在上面使用 v-if，最终的渲染结果中不包含它。 v-show和 v-if的使用方式基本相同，差别在于: v-if 是真实的条件渲染，因为它会确保条件块在切换当中适当地销毁与重建条件块内的事件监听器和子组件。 v-if 也是 惰性 的：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。 相比之下， v-show 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换 (display: none)。 v-else紧跟在 v-if或者 v-show后面才用意义 列表渲染 基本用法 1234567891011121314&lt;ul id="example-1"&gt; &lt;li v-for="item in items"&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt;var example1 = new Vue(&#123; el: '#example-1', data: &#123; items: [ &#123;message: 'foo' &#125;, &#123;message: 'Bar' &#125; ] &#125;&#125;) of 替代 in 作为分隔符，因为它是最接近 JavaScript 迭代器的语法 1&lt;div v-for="item of items"&gt;&lt;/div&gt; 如同 v-if 模板，你也可以用带有 v-for 的 标签来渲染多个元素块 123456&lt;ul&gt; &lt;template v-for="item in items"&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class="divider"&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; v-for 可以通过一个独享的属性来迭代 123456789101112131415&lt;ul id="repeat-object" class="demo"&gt; &lt;li v-for="value in object"&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt;new Vue(&#123; el: '#repeat-object', data: &#123; object: &#123; FirstName: 'John', LastName: 'Doe', Age: 30 &#125; &#125;&#125;) 可以提供第二个的参数为键名：123&lt;div v-for="(value, key) in object"&gt; &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/div&gt; 第三个参数为索引：123&lt;div v-for="(value, key, index) in object"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/div&gt; // todo 本文仅作为个人的随身读书笔记收集，没有用于任何商业盈利范畴。如若有侵犯源作者的著作权，请联系本人（立马撤文）mstarzheng@foxmail.com]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
